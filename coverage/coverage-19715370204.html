
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent-align: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">agent-align/cmd/agent-align/additional.go (71.4%)</option>
				
				<option value="file1">agent-align/cmd/agent-align/extra_targets.go (73.7%)</option>
				
				<option value="file2">agent-align/cmd/agent-align/main.go (41.7%)</option>
				
				<option value="file3">agent-align/internal/config/config.go (78.0%)</option>
				
				<option value="file4">agent-align/internal/syncer/syncer.go (94.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "agent-align/internal/config"
)

func buildAdditionalJSONContent(target config.AdditionalJSONTarget, servers map[string]interface{}) (string, error) <span class="cov8" title="1">{
        pathSegments := jsonPathSegments(target.JSONPath)
        if len(pathSegments) == 0 </span><span class="cov8" title="1">{
                return marshalJSON(servers)
        }</span>

        <span class="cov8" title="1">root, err := loadJSONFile(target.FilePath)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">mergeJSONValue(root, pathSegments, servers)
        return marshalJSON(root)</span>
}

func loadJSONFile(path string) (map[string]interface{}, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return make(map[string]interface{}), nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read %s: %w", path, err)</span>
        }

        <span class="cov8" title="1">trimmed := strings.TrimSpace(string(data))
        if trimmed == "" </span><span class="cov0" title="0">{
                return make(map[string]interface{}), nil
        }</span>

        <span class="cov8" title="1">var out map[string]interface{}
        if err := json.Unmarshal(data, &amp;out); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse JSON from %s: %w", path, err)
        }</span>
        <span class="cov8" title="1">if out == nil </span><span class="cov0" title="0">{
                out = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func marshalJSON(value interface{}) (string, error) <span class="cov8" title="1">{
        data, err := json.MarshalIndent(value, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal JSON: %w", err)
        }</span>
        <span class="cov8" title="1">return string(data) + "\n", nil</span>
}

func mergeJSONValue(root map[string]interface{}, path []string, value interface{}) <span class="cov8" title="1">{
        current := root
        for i, segment := range path </span><span class="cov8" title="1">{
                if i == len(path)-1 </span><span class="cov8" title="1">{
                        current[segment] = value
                        return
                }</span>
                <span class="cov0" title="0">next, ok := current[segment].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        next = make(map[string]interface{})
                        current[segment] = next
                }</span>
                <span class="cov0" title="0">current = next</span>
        }
}

func jsonPathSegments(path string) []string <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(path)
        if trimmed == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">segments := strings.Split(trimmed, ".")
        var out []string
        for _, segment := range segments </span><span class="cov8" title="1">{
                if segment == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">out = append(out, segment)</span>
        }
        <span class="cov8" title="1">return out</span>
}

func displayJSONPath(path string) string <span class="cov0" title="0">{
        if trimmed := strings.TrimSpace(path); trimmed != "" </span><span class="cov0" title="0">{
                return trimmed
        }</span>
        <span class="cov0" title="0">return "&lt;root&gt;"</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "io"
        "io/fs"
        "os"
        "path/filepath"

        "agent-align/internal/config"
)

func copyExtraFileTarget(target config.ExtraFileTarget) error <span class="cov8" title="1">{
        info, err := os.Stat(target.Source)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to inspect %s: %w", target.Source, err)
        }</span>
        <span class="cov8" title="1">if info.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("extra file target %s is a directory; use directories instead", target.Source)
        }</span>
        <span class="cov8" title="1">for _, dest := range target.Destinations </span><span class="cov8" title="1">{
                if err := copyFileContents(target.Source, dest, info.Mode()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to copy %s to %s: %w", target.Source, dest, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func copyExtraDirectoryTarget(target config.ExtraDirectoryTarget) (int, error) <span class="cov8" title="1">{
        sourceInfo, err := os.Stat(target.Source)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to inspect %s: %w", target.Source, err)
        }</span>
        <span class="cov8" title="1">if !sourceInfo.IsDir() </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("extra directory target %s is not a directory", target.Source)
        }</span>

        <span class="cov8" title="1">var total int
        for _, dest := range target.Destinations </span><span class="cov8" title="1">{
                count, err := copyDirectory(target.Source, dest.Path, dest.Flatten)
                if err != nil </span><span class="cov0" title="0">{
                        return total, fmt.Errorf("failed to copy directory %s to %s: %w", target.Source, dest.Path, err)
                }</span>
                <span class="cov8" title="1">total += count</span>
        }
        <span class="cov8" title="1">return total, nil</span>
}

func copyDirectory(source, destination string, flatten bool) (int, error) <span class="cov8" title="1">{
        var copied int
        walkErr := filepath.WalkDir(source, func(path string, entry fs.DirEntry, walkErr error) error </span><span class="cov8" title="1">{
                if walkErr != nil </span><span class="cov0" title="0">{
                        return walkErr
                }</span>
                <span class="cov8" title="1">if entry.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">var destPath string
                if flatten </span><span class="cov8" title="1">{
                        destPath = filepath.Join(destination, filepath.Base(path))
                }</span> else<span class="cov8" title="1"> {
                        rel, err := filepath.Rel(source, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">destPath = filepath.Join(destination, rel)</span>
                }

                <span class="cov8" title="1">info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := copyFileContents(path, destPath, info.Mode()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">copied++
                return nil</span>
        })
        <span class="cov8" title="1">if walkErr != nil </span><span class="cov0" title="0">{
                return copied, walkErr
        }</span>
        <span class="cov8" title="1">return copied, nil</span>
}

func copyFileContents(source, dest string, mode os.FileMode) error <span class="cov8" title="1">{
        in, err := os.Open(source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer in.Close()

        if err := os.MkdirAll(filepath.Dir(dest), 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory for %s: %w", dest, err)
        }</span>

        <span class="cov8" title="1">out, err := os.OpenFile(dest, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, mode.Perm())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open %s: %w", dest, err)
        }</span>
        <span class="cov8" title="1">defer out.Close()

        if _, err := io.Copy(out, in); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy %s to %s: %w", source, dest, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "bufio"
        _ "embed"
        "errors"
        "flag"
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "runtime"
        "sort"
        "strconv"
        "strings"
        "unicode"

        "gopkg.in/yaml.v3"

        "agent-align/internal/config"
        "agent-align/internal/syncer"
)

const (
        defaultAgents = "copilot,vscode,codex,claudecode,gemini"
)

var (
        promptUser      = askYes
        collectConfig   = promptForConfig
        supportedAgents = []string{"codex", "vscode", "gemini", "copilot", "claudecode"}
)

//go:embed config.example.yml
var exampleConfig string

func main() <span class="cov0" title="0">{
        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == "init" </span><span class="cov0" title="0">{
                if err := runInitCommand(os.Args[2:]); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("init failed: %v", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">if err := validateCommand(os.Args); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">sourceAgent := flag.String("source", "", "source-of-truth agent name")
        agents := flag.String("agents", "", fmt.Sprintf("comma-separated list of agents to keep in sync (defaults to %s)", defaultAgents))
        configPath := flag.String("config", defaultConfigPath(), "path to YAML configuration file describing the source and target agents")
        dryRun := flag.Bool("dry-run", false, "only show what would be changed without applying changes")
        confirm := flag.Bool("confirm", false, "skip user confirmation prompt (useful for cron jobs)")

        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: agent-align [OPTIONS]\n\n")
                fmt.Fprintf(os.Stderr, "Options:\n")
                flag.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nDefault config file location: %s\n", defaultConfigPath())
                fmt.Fprintf(os.Stderr, "\nExample config file:\n%s\n", exampleConfig)
                fmt.Fprintf(os.Stderr, "Tip: add agent-align to cron for continuous syncing, e.g.:\n")
                fmt.Fprintf(os.Stderr, "  0 * * * * agent-align -confirm &gt;/tmp/agent-align.log 2&gt;&amp;1\n\n")
        }</span>

        <span class="cov0" title="0">flag.Parse()

        var configFlagUsed bool
        flag.Visit(func(f *flag.Flag) </span><span class="cov0" title="0">{
                if f.Name == "config" </span><span class="cov0" title="0">{
                        configFlagUsed = true
                }</span>
        })

        <span class="cov0" title="0">useConfig, modeErr := resolveExecutionMode(*sourceAgent, *agents, configFlagUsed)
        if modeErr != nil </span><span class="cov0" title="0">{
                log.Fatal(modeErr)
        }</span>

        <span class="cov0" title="0">var finalSource string
        var candidateAgents []string
        var additionalTargets []config.AdditionalJSONTarget
        var extraTargets config.ExtraTargetsConfig

        if useConfig </span><span class="cov0" title="0">{
                if err := ensureConfigFile(*configPath); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("configuration unavailable: %v", err)
                }</span>

                <span class="cov0" title="0">cfg, cfgErr := config.Load(*configPath)
                if cfgErr != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to load config %q: %v", *configPath, cfgErr)
                }</span>
                <span class="cov0" title="0">finalSource = cfg.SourceAgent
                candidateAgents = cfg.Targets.Agents
                additionalTargets = cfg.Targets.Additional.JSON
                extraTargets = cfg.ExtraTargets</span>
        } else<span class="cov0" title="0"> {
                finalSource = strings.TrimSpace(*sourceAgent)
                candidateAgents = parseAgents(*agents)
                if len(candidateAgents) == 0 </span><span class="cov0" title="0">{
                        log.Fatal("the -agents flag must list at least one agent")
                }</span>
        }

        <span class="cov0" title="0">if strings.TrimSpace(finalSource) == "" </span><span class="cov0" title="0">{
                log.Fatal("source agent must be provided via a config file or -source/-agents")
        }</span>
        <span class="cov0" title="0">if len(candidateAgents) == 0 &amp;&amp; len(additionalTargets) == 0 &amp;&amp; extraTargets.IsZero() </span><span class="cov0" title="0">{
                log.Fatal("no target agents, additional destinations, or extra copy targets configured; provide agents via config/flags or add extra targets")
        }</span>

        <span class="cov0" title="0">sourceCfg, err := syncer.GetAgentConfig(finalSource)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to locate source agent config for %s: %v", finalSource, err)
        }</span>
        <span class="cov0" title="0">tpl, err := syncer.LoadTemplateFromFile(sourceCfg.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to load template: %v", err)
        }</span>

        <span class="cov0" title="0">s := syncer.New(finalSource, candidateAgents)

        syncResult, err := s.Sync(tpl)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("sync failed: %v", err)
        }</span>

        // Display the dry run results
        <span class="cov0" title="0">fmt.Println("\n=== Dry Run Results ===")
        fmt.Println("The following configuration changes will be made:")
        fmt.Println()

        for agent, cfgContent := range syncResult.Agents </span><span class="cov0" title="0">{
                agentCfg, err := syncer.GetAgentConfig(agent)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: could not get config for agent %s: %v", agent, err)
                        continue</span>
                }
                <span class="cov0" title="0">fmt.Printf("Agent: %s\n", agent)
                fmt.Printf("  File: %s\n", agentCfg.FilePath)
                fmt.Printf("  Format: %s\n", agentCfg.Format)
                fmt.Printf("  Content:\n")
                // Indent the content for readability
                lines := strings.Split(cfgContent, "\n")
                for _, line := range lines </span><span class="cov0" title="0">{
                        fmt.Printf("    %s\n", line)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">if len(additionalTargets) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Additional destinations:")
                for _, target := range additionalTargets </span><span class="cov0" title="0">{
                        fmt.Printf("Additional JSON: %s\n", target.FilePath)
                        fmt.Printf("  JSON Path: %s\n", displayJSONPath(target.JSONPath))
                        content, err := buildAdditionalJSONContent(target, syncResult.Servers)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("  (error preparing content: %v)\n\n", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">content = strings.TrimRight(content, "\n")
                        if content == "" </span><span class="cov0" title="0">{
                                fmt.Println("  Content: &lt;empty&gt;")
                                fmt.Println()
                                continue</span>
                        }
                        <span class="cov0" title="0">fmt.Println("  Content:")
                        lines := strings.Split(content, "\n")
                        for _, line := range lines </span><span class="cov0" title="0">{
                                fmt.Printf("    %s\n", line)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }

        <span class="cov0" title="0">if !extraTargets.IsZero() </span><span class="cov0" title="0">{
                fmt.Println("Extra copy targets:")
                for _, target := range extraTargets.Files </span><span class="cov0" title="0">{
                        fmt.Printf("File Source: %s\n", target.Source)
                        for _, dest := range target.Destinations </span><span class="cov0" title="0">{
                                fmt.Printf("  -&gt; %s\n", dest)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
                <span class="cov0" title="0">for _, target := range extraTargets.Directories </span><span class="cov0" title="0">{
                        fmt.Printf("Directory Source: %s\n", target.Source)
                        fmt.Println("  Destinations:")
                        for _, dest := range target.Destinations </span><span class="cov0" title="0">{
                                label := dest.Path
                                if dest.Flatten </span><span class="cov0" title="0">{
                                        label = fmt.Sprintf("%s (flatten)", label)
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("    - %s\n", label)</span>
                        }
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }

        // If dry-run mode, exit without making changes
        <span class="cov0" title="0">if *dryRun </span><span class="cov0" title="0">{
                fmt.Println("Dry run complete. No changes were made.")
                return
        }</span>

        // If not in confirm mode, ask for user confirmation
        <span class="cov0" title="0">if !*confirm </span><span class="cov0" title="0">{
                if !promptUser("Apply these changes? [y/N]: ", false) </span><span class="cov0" title="0">{
                        fmt.Println("Changes cancelled.")
                        return
                }</span>
        }

        // Apply the changes
        <span class="cov0" title="0">fmt.Println("\nApplying changes...")
        for agent, cfgContent := range syncResult.Agents </span><span class="cov0" title="0">{
                agentCfg, err := syncer.GetAgentConfig(agent)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: could not get config for agent %s: %v", agent, err)
                        continue</span>
                }

                <span class="cov0" title="0">if err := writeAgentConfig(agentCfg.FilePath, cfgContent); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing config for %s: %v", agent, err)
                        continue</span>
                }
                <span class="cov0" title="0">fmt.Printf("  Updated: %s\n", agentCfg.FilePath)</span>
        }

        <span class="cov0" title="0">for _, target := range additionalTargets </span><span class="cov0" title="0">{
                content, err := buildAdditionalJSONContent(target, syncResult.Servers)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error preparing additional JSON %s: %v", target.FilePath, err)
                        continue</span>
                }
                <span class="cov0" title="0">if err := writeAgentConfig(target.FilePath, content); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing additional JSON %s: %v", target.FilePath, err)
                        continue</span>
                }
                <span class="cov0" title="0">fmt.Printf("  Updated additional JSON: %s\n", target.FilePath)
                if target.JSONPath != "" </span><span class="cov0" title="0">{
                        fmt.Printf("    JSON Path: %s\n", target.JSONPath)
                }</span>
        }

        <span class="cov0" title="0">for _, target := range extraTargets.Files </span><span class="cov0" title="0">{
                if err := copyExtraFileTarget(target); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error copying extra file %s: %v", target.Source, err)
                        continue</span>
                }
                <span class="cov0" title="0">fmt.Printf("  Copied extra file: %s -&gt; %d destinations\n", target.Source, len(target.Destinations))</span>
        }
        <span class="cov0" title="0">for _, target := range extraTargets.Directories </span><span class="cov0" title="0">{
                count, err := copyExtraDirectoryTarget(target)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error copying extra directory %s: %v", target.Source, err)
                        continue</span>
                }
                <span class="cov0" title="0">fmt.Printf("  Copied extra directory: %s -&gt; %d destination(s) (%d files)\n", target.Source, len(target.Destinations), count)
                var flattened bool
                for _, dest := range target.Destinations </span><span class="cov0" title="0">{
                        if dest.Flatten </span><span class="cov0" title="0">{
                                flattened = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if flattened </span><span class="cov0" title="0">{
                        fmt.Println("    Applied flatten to some destinations")
                }</span>
        }
        <span class="cov0" title="0">fmt.Println("\nConfiguration sync complete.")</span>
}

func parseAgents(agents string) []string <span class="cov8" title="1">{
        segments := strings.Split(agents, ",")
        var out []string
        for _, segment := range segments </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(segment)
                if trimmed == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">out = append(out, trimmed)</span>
        }
        <span class="cov8" title="1">return out</span>
}

func defaultConfigPath() string <span class="cov8" title="1">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                return "/usr/local/etc/agent-align.yml"</span>
        case "windows":<span class="cov0" title="0">
                if base := os.Getenv("ProgramData"); base != "" </span><span class="cov0" title="0">{
                        return filepath.Join(base, "agent-align", "config.yml")
                }</span>
                <span class="cov0" title="0">return `C:\ProgramData\agent-align\config.yml`</span>
        default:<span class="cov8" title="1">
                return "/etc/agent-align.yml"</span>
        }
}

func ensureConfigFile(path string) error <span class="cov8" title="1">{
        if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov8" title="1"> if !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to inspect %q: %w", path, err)
        }</span>

        <span class="cov8" title="1">prompt := fmt.Sprintf("Configuration %s not found. %sCreate a default config? [Y/n]: ", path, configPromptSuffix(path))
        if !promptUser(prompt, true) </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration file %s is required", path)
        }</span>

        <span class="cov8" title="1">cfg, err := collectConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to collect configuration: %w", err)
        }</span>
        <span class="cov8" title="1">if err := writeConfigFile(path, cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">fmt.Printf("Created configuration file at %s\n", path)
        return nil</span>
}

func runInitCommand(args []string) error <span class="cov8" title="1">{
        initFlags := flag.NewFlagSet("init", flag.ExitOnError)
        configPath := initFlags.String("config", defaultConfigPath(), "path to YAML configuration file to create")
        if err := initFlags.Parse(args); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">path := *configPath
        if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                if !promptUser(fmt.Sprintf("Configuration already exists at %s. Overwrite? [y/N]: ", path), false) </span><span class="cov8" title="1">{
                        fmt.Println("Init cancelled.")
                        return nil
                }</span>
        } else<span class="cov8" title="1"> if !errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to inspect %q: %w", path, err)
        }</span>

        <span class="cov8" title="1">cfg, err := collectConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to collect configuration: %w", err)
        }</span>
        <span class="cov8" title="1">if err := writeConfigFile(path, cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">fmt.Printf("Created configuration file at %s\n", path)
        return nil</span>
}

func askYes(prompt string, defaultYes bool) bool <span class="cov8" title="1">{
        reader := bufio.NewReader(os.Stdin)
        for </span><span class="cov8" title="1">{
                fmt.Print(prompt)
                input, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return defaultYes
                }</span>

                <span class="cov8" title="1">response := strings.TrimSpace(strings.ToLower(input))
                if response == "" </span><span class="cov0" title="0">{
                        return defaultYes
                }</span>

                <span class="cov8" title="1">switch response </span>{
                case "y", "yes":<span class="cov8" title="1">
                        return true</span>
                case "n", "no":<span class="cov8" title="1">
                        return false</span>
                default:<span class="cov8" title="1">
                        fmt.Println("Please answer 'y' or 'n'.")</span>
                }
        }
}

func promptForConfig() (config.Config, error) <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        fmt.Println("\nLet's create your agent-align configuration.")
        source, err := promptSourceAgent(reader)
        if err != nil </span><span class="cov0" title="0">{
                return config.Config{}, err
        }</span>
        <span class="cov0" title="0">targets, err := promptTargetAgents(reader, source)
        if err != nil </span><span class="cov0" title="0">{
                return config.Config{}, err
        }</span>
        <span class="cov0" title="0">additionalJSON, err := promptAdditionalJSONTargets(reader)
        if err != nil </span><span class="cov0" title="0">{
                return config.Config{}, err
        }</span>
        <span class="cov0" title="0">additional := config.AdditionalTargets{}
        if len(additionalJSON) &gt; 0 </span><span class="cov0" title="0">{
                additional.JSON = additionalJSON
        }</span>
        <span class="cov0" title="0">return config.Config{
                SourceAgent: source,
                Targets: config.TargetsConfig{
                        Agents:     targets,
                        Additional: additional,
                },
        }, nil</span>
}

func configPromptSuffix(path string) string <span class="cov8" title="1">{
        if path == defaultConfigPath() </span><span class="cov0" title="0">{
                return "Use -config to choose another path. "
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func promptSourceAgent(reader *bufio.Reader) (string, error) <span class="cov8" title="1">{
        displayAgents := append([]string{}, supportedAgents...)
        sort.Strings(displayAgents)
        fmt.Println("\nSelect the source agent:")
        for i, agent := range displayAgents </span><span class="cov8" title="1">{
                fmt.Printf("  %d) %s\n", i+1, agent)
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                fmt.Printf("Enter choice [1-%d]: ", len(displayAgents))
                input, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">choice, convErr := strconv.Atoi(strings.TrimSpace(input))
                if convErr != nil || choice &lt; 1 || choice &gt; len(supportedAgents) </span><span class="cov8" title="1">{
                        fmt.Println("Please enter a number from the list above.")
                        continue</span>
                }
                <span class="cov8" title="1">return supportedAgents[choice-1], nil</span>
        }
}

func promptTargetAgents(reader *bufio.Reader, source string) ([]string, error) <span class="cov8" title="1">{
        options := make([]string, 0, len(supportedAgents)-1)
        for _, agent := range supportedAgents </span><span class="cov8" title="1">{
                if agent == source </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">options = append(options, agent)</span>
        }
        <span class="cov8" title="1">if len(options) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no target agents available for source %q", source)
        }</span>

        <span class="cov8" title="1">sort.Strings(options)
        fmt.Println("\nSelect target agents (enter comma-separated numbers, e.g. 1,3):")
        for i, agent := range options </span><span class="cov8" title="1">{
                fmt.Printf("  %d) %s\n", i+1, agent)
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                fmt.Print("Enter one or more choices: ")
                line, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">selections, parseErr := parseSelectionIndices(line)
                if parseErr != nil </span><span class="cov0" title="0">{
                        fmt.Println(parseErr)
                        continue</span>
                }
                <span class="cov8" title="1">seen := make(map[int]struct{}, len(selections))
                var targets []string
                valid := true
                for _, idx := range selections </span><span class="cov8" title="1">{
                        if idx &lt; 1 || idx &gt; len(options) </span><span class="cov8" title="1">{
                                fmt.Printf("Selection %d is out of range. Please use numbers from the list.\n", idx)
                                valid = false
                                break</span>
                        }
                        <span class="cov8" title="1">if _, exists := seen[idx]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">seen[idx] = struct{}{}
                        targets = append(targets, options[idx-1])</span>
                }
                <span class="cov8" title="1">if !valid </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if len(targets) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("Please select at least one target agent.")
                        continue</span>
                }
                <span class="cov8" title="1">return targets, nil</span>
        }
}

func parseSelectionIndices(input string) ([]int, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(input)
        if trimmed == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Please enter at least one selection.")
        }</span>
        <span class="cov8" title="1">segments := strings.FieldsFunc(trimmed, func(r rune) bool </span><span class="cov8" title="1">{
                return r == ',' || unicode.IsSpace(r)
        }</span>)
        <span class="cov8" title="1">if len(segments) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Please enter at least one selection.")
        }</span>
        <span class="cov8" title="1">var selections []int
        for _, segment := range segments </span><span class="cov8" title="1">{
                value, err := strconv.Atoi(segment)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%q is not a valid number", segment)
                }</span>
                <span class="cov8" title="1">selections = append(selections, value)</span>
        }
        <span class="cov8" title="1">return selections, nil</span>
}

func promptAdditionalJSONTargets(reader *bufio.Reader) ([]config.AdditionalJSONTarget, error) <span class="cov8" title="1">{
        fmt.Println("\nAdd optional MCP destinations (custom files outside the built-in agents).")
        var targets []config.AdditionalJSONTarget

        for </span><span class="cov8" title="1">{
                addMore, err := promptYesNoInput(reader, "Add an additional JSON destination? [y/N]: ", false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if !addMore </span><span class="cov8" title="1">{
                        return targets, nil
                }</span>

                <span class="cov8" title="1">filePath, err := promptRequiredValue(reader, "Enter the destination file path: ", "Please enter a file path.")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">jsonPath, err := promptRequiredValue(reader, "Enter the JSON path within that file (e.g. .mcpServers): ", "Please enter a JSON path.")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">targets = append(targets, config.AdditionalJSONTarget{
                        FilePath: filePath,
                        JSONPath: jsonPath,
                })</span>
        }
}

func promptYesNoInput(reader *bufio.Reader, prompt string, defaultYes bool) (bool, error) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                fmt.Print(prompt)
                input, err := reader.ReadString('\n')
                if err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov8" title="1">response := strings.TrimSpace(strings.ToLower(input))
                if response == "" </span><span class="cov0" title="0">{
                        return defaultYes, nil
                }</span>

                <span class="cov8" title="1">switch response </span>{
                case "y", "yes":<span class="cov8" title="1">
                        return true, nil</span>
                case "n", "no":<span class="cov8" title="1">
                        return false, nil</span>
                default:<span class="cov0" title="0">
                        fmt.Println("Please answer 'y' or 'n'.")
                        if err != nil &amp;&amp; errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                                return defaultYes, nil
                        }</span>
                }
        }
}

func promptRequiredValue(reader *bufio.Reader, prompt, emptyMsg string) (string, error) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                fmt.Print(prompt)
                input, err := reader.ReadString('\n')
                if err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">value := strings.TrimSpace(input)
                if value == "" </span><span class="cov8" title="1">{
                        fmt.Println(emptyMsg)
                        if err != nil &amp;&amp; errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                                return "", errors.New(emptyMsg)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">return value, nil</span>
        }
}

func writeConfigFile(path string, cfg config.Config) error <span class="cov8" title="1">{
        data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate config contents: %w", err)
        }</span>
        <span class="cov8" title="1">dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure directory %q: %w", dir, err)
        }</span>
        <span class="cov8" title="1">if err := os.WriteFile(path, data, 0o644); err != nil </span><span class="cov0" title="0">{
                printManualConfigInstructions(path, data)
                return fmt.Errorf("failed to write config %q: %w", path, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func printManualConfigInstructions(path string, contents []byte) <span class="cov0" title="0">{
        fmt.Fprintf(os.Stderr, "\nUnable to write the config file automatically. Please create %s with the following contents:\n\n%s\n", path, contents)
}</span>

func writeAgentConfig(path, content string) error <span class="cov0" title="0">{
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure directory %q: %w", dir, err)
        }</span>
        <span class="cov0" title="0">if err := os.WriteFile(path, []byte(content), 0o644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config %q: %w", path, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateCommand(args []string) error <span class="cov8" title="1">{
        if len(args) &lt;= 1 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">arg := args[1]
        if arg == "" || arg == "init" || strings.HasPrefix(arg, "-") </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("unknown command %q. Use -h for usage or run \"init\" to create a config.", arg)</span>
}

func resolveExecutionMode(sourceFlag, agentsFlag string, configFlagUsed bool) (bool, error) <span class="cov8" title="1">{
        sourceProvided := strings.TrimSpace(sourceFlag) != ""
        agentsProvided := strings.TrimSpace(agentsFlag) != ""

        if configFlagUsed &amp;&amp; (sourceProvided || agentsProvided) </span><span class="cov8" title="1">{
                return true, fmt.Errorf("-config cannot be combined with -source or -agents")
        }</span>
        <span class="cov8" title="1">if sourceProvided != agentsProvided </span><span class="cov8" title="1">{
                return true, fmt.Errorf("use -source and -agents together or rely entirely on the config file")
        }</span>
        <span class="cov8" title="1">return !sourceProvided, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "gopkg.in/yaml.v3"
)

// Config describes the MCP sync behavior and extra file/directory copies.
type Config struct {
        SourceAgent  string
        Targets      TargetsConfig
        ExtraTargets ExtraTargetsConfig
}

// TargetsConfig groups agent targets and additional destinations.
type TargetsConfig struct {
        Agents     []string          `yaml:"agents"`
        Additional AdditionalTargets `yaml:"additionalTargets"`
}

// AdditionalTargets lists paths for JSON-style destinations.
type AdditionalTargets struct {
        JSON []AdditionalJSONTarget `yaml:"json"`
}

// ExtraTargetsConfig describes file/directory copy operations outside the MCP sync.
type ExtraTargetsConfig struct {
        Files       []ExtraFileTarget      `yaml:"files"`
        Directories []ExtraDirectoryTarget `yaml:"directories"`
}

// ExtraFileTarget copies a single source file into multiple destinations.
type ExtraFileTarget struct {
        Source       string   `yaml:"source"`
        Destinations []string `yaml:"destinations"`
}

// ExtraDirectoryTarget copies an entire directory, optionally flattening the files.
type ExtraDirectoryTarget struct {
        Source       string                    `yaml:"source"`
        Destinations []ExtraDirectoryCopyRoute `yaml:"destinations"`
}

// ExtraDirectoryCopyRoute describes how a single destination should be written.
type ExtraDirectoryCopyRoute struct {
        Path    string `yaml:"path"`
        Flatten bool   `yaml:"flatten"`
}

// AdditionalJSONTarget describes a JSON file that should receive the MCP payload.
type AdditionalJSONTarget struct {
        FilePath string `yaml:"filePath"`
        JSONPath string `yaml:"jsonPath"`
}

// Load reads the YAML configuration from the given path and validates it.
func Load(path string) (Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return Config{}, err
        }</span>

        <span class="cov8" title="1">var cfg Config
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov8" title="1">{
                return Config{}, fmt.Errorf("failed to parse config at %q: %w", path, err)
        }</span>

        <span class="cov8" title="1">cfg.SourceAgent = normalizeAgent(cfg.SourceAgent)
        if cfg.SourceAgent == "" </span><span class="cov0" title="0">{
                return Config{}, fmt.Errorf("config at %q must define a source agent", path)
        }</span>

        <span class="cov8" title="1">cleanAgents := make([]string, 0, len(cfg.Targets.Agents))
        for _, target := range cfg.Targets.Agents </span><span class="cov8" title="1">{
                trimmed := normalizeAgent(target)
                if trimmed == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">cleanAgents = append(cleanAgents, trimmed)</span>
        }

        <span class="cov8" title="1">for _, target := range cleanAgents </span><span class="cov8" title="1">{
                if target == cfg.SourceAgent </span><span class="cov8" title="1">{
                        return Config{}, fmt.Errorf("config at %q lists %q as both source and target; remove it from targets", path, target)
                }</span>
        }

        <span class="cov8" title="1">cfg.Targets.Agents = cleanAgents
        for i := range cfg.Targets.Additional.JSON </span><span class="cov8" title="1">{
                cfg.Targets.Additional.JSON[i].FilePath = strings.TrimSpace(cfg.Targets.Additional.JSON[i].FilePath)
                cfg.Targets.Additional.JSON[i].JSONPath = strings.TrimSpace(cfg.Targets.Additional.JSON[i].JSONPath)
                if cfg.Targets.Additional.JSON[i].FilePath == "" </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an additional JSON target without a filePath", path)
                }</span>
                <span class="cov8" title="1">expanded, err := expandUserPath(cfg.Targets.Additional.JSON[i].FilePath)
                if err != nil </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an additional JSON target with invalid filePath %q: %w", path, cfg.Targets.Additional.JSON[i].FilePath, err)
                }</span>
                <span class="cov8" title="1">cfg.Targets.Additional.JSON[i].FilePath = expanded</span>
        }

        <span class="cov8" title="1">for i := range cfg.ExtraTargets.Files </span><span class="cov8" title="1">{
                source := strings.TrimSpace(cfg.ExtraTargets.Files[i].Source)
                if source == "" </span><span class="cov8" title="1">{
                        return Config{}, fmt.Errorf("config at %q has an extra file target without a source", path)
                }</span>
                <span class="cov8" title="1">expandedSource, err := expandUserPath(source)
                if err != nil </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an extra file target with invalid source %q: %w", path, source, err)
                }</span>
                <span class="cov8" title="1">cfg.ExtraTargets.Files[i].Source = expandedSource
                var dests []string
                for _, dest := range cfg.ExtraTargets.Files[i].Destinations </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(dest)
                        if trimmed == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">expandedDest, err := expandUserPath(trimmed)
                        if err != nil </span><span class="cov0" title="0">{
                                return Config{}, fmt.Errorf("config at %q has an extra file target destination %q: %w", path, trimmed, err)
                        }</span>
                        <span class="cov8" title="1">dests = append(dests, expandedDest)</span>
                }
                <span class="cov8" title="1">if len(dests) == 0 </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an extra file target for %q without destinations", path, source)
                }</span>
                <span class="cov8" title="1">cfg.ExtraTargets.Files[i].Destinations = dests</span>
        }

        <span class="cov8" title="1">for i := range cfg.ExtraTargets.Directories </span><span class="cov8" title="1">{
                source := strings.TrimSpace(cfg.ExtraTargets.Directories[i].Source)
                if source == "" </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an extra directory target without a source", path)
                }</span>
                <span class="cov8" title="1">expandedSource, err := expandUserPath(source)
                if err != nil </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an extra directory target with invalid source %q: %w", path, source, err)
                }</span>
                <span class="cov8" title="1">cfg.ExtraTargets.Directories[i].Source = expandedSource
                var routes []ExtraDirectoryCopyRoute
                for _, dest := range cfg.ExtraTargets.Directories[i].Destinations </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(dest.Path)
                        if trimmed == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">expandedPath, err := expandUserPath(trimmed)
                        if err != nil </span><span class="cov0" title="0">{
                                return Config{}, fmt.Errorf("config at %q has an extra directory destination %q: %w", path, trimmed, err)
                        }</span>
                        <span class="cov8" title="1">routes = append(routes, ExtraDirectoryCopyRoute{
                                Path:    expandedPath,
                                Flatten: dest.Flatten,
                        })</span>
                }
                <span class="cov8" title="1">if len(routes) == 0 </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an extra directory target for %q without destinations", path, source)
                }</span>
                <span class="cov8" title="1">cfg.ExtraTargets.Directories[i].Destinations = routes</span>
        }

        <span class="cov8" title="1">if len(cfg.Targets.Agents) == 0 &amp;&amp;
                len(cfg.Targets.Additional.JSON) == 0 &amp;&amp;
                cfg.ExtraTargets.IsZero() </span><span class="cov8" title="1">{
                return Config{}, fmt.Errorf("config at %q must define at least one target", path)
        }</span>

        <span class="cov8" title="1">return cfg, nil</span>
}

func normalizeAgent(value string) string <span class="cov8" title="1">{
        return strings.ToLower(strings.TrimSpace(value))
}</span>

func expandUserPath(value string) (string, error) <span class="cov8" title="1">{
        value = strings.TrimSpace(value)
        if value == "" || value[0] != '~' </span><span class="cov8" title="1">{
                return value, nil
        }</span>
        <span class="cov8" title="1">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("resolve home directory: %w", err)
        }</span>
        <span class="cov8" title="1">if len(value) == 1 </span><span class="cov0" title="0">{
                return home, nil
        }</span>
        <span class="cov8" title="1">switch value[1] </span>{
        case '/', '\\':<span class="cov8" title="1">
                remainder := strings.TrimLeft(value[1:], "/\\")
                if remainder == "" </span><span class="cov0" title="0">{
                        return home, nil
                }</span>
                <span class="cov8" title="1">return filepath.Clean(filepath.Join(home, remainder)), nil</span>
        default:<span class="cov0" title="0">
                return value, nil</span>
        }
}

// MarshalYAML outputs the nested structure with mcpServers/extraTargets.
func (c Config) MarshalYAML() (interface{}, error) <span class="cov0" title="0">{
        type mcpServers struct {
                SourceAgent string        `yaml:"sourceAgent"`
                Targets     TargetsConfig `yaml:"targets"`
        }
        type output struct {
                MCPServers   mcpServers         `yaml:"mcpServers"`
                ExtraTargets ExtraTargetsConfig `yaml:"extraTargets,omitempty"`
        }
        return output{
                MCPServers: mcpServers{
                        SourceAgent: c.SourceAgent,
                        Targets:     c.Targets,
                },
                ExtraTargets: c.ExtraTargets,
        }, nil
}</span>

// UnmarshalYAML supports legacy top-level fields in addition to mcpServers.
func (c *Config) UnmarshalYAML(node *yaml.Node) error <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">type mcpBlock struct {
                Source      string        `yaml:"source"`
                SourceAgent string        `yaml:"sourceAgent"`
                Targets     TargetsConfig `yaml:"targets"`
        }
        type rawConfig struct {
                MCPServers   *mcpBlock          `yaml:"mcpServers"`
                Source       string             `yaml:"source"`
                SourceAgent  string             `yaml:"sourceAgent"`
                Targets      TargetsConfig      `yaml:"targets"`
                ExtraTargets ExtraTargetsConfig `yaml:"extraTargets"`
        }

        var raw rawConfig
        if err := node.Decode(&amp;raw); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">c.ExtraTargets = raw.ExtraTargets
        switch </span>{
        case raw.MCPServers != nil:<span class="cov8" title="1">
                c.Targets = raw.MCPServers.Targets
                if raw.MCPServers.SourceAgent != "" </span><span class="cov8" title="1">{
                        c.SourceAgent = raw.MCPServers.SourceAgent
                }</span> else<span class="cov0" title="0"> {
                        c.SourceAgent = raw.MCPServers.Source
                }</span>
        default:<span class="cov8" title="1">
                c.Targets = raw.Targets
                if raw.SourceAgent != "" </span><span class="cov8" title="1">{
                        c.SourceAgent = raw.SourceAgent
                }</span> else<span class="cov8" title="1"> {
                        c.SourceAgent = raw.Source
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// UnmarshalYAML accepts both the legacy target list and the new mapping.
func (t *TargetsConfig) UnmarshalYAML(node *yaml.Node) error <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">switch node.Kind </span>{
        case yaml.SequenceNode:<span class="cov8" title="1">
                var agents []string
                if err := node.Decode(&amp;agents); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">t.Agents = agents
                return nil</span>
        case yaml.MappingNode:<span class="cov8" title="1">
                type rawTargets struct {
                        Agents            []string          `yaml:"agents"`
                        Additional        AdditionalTargets `yaml:"additional"`
                        AdditionalTargets AdditionalTargets `yaml:"additionalTargets"`
                }
                var raw rawTargets
                if err := node.Decode(&amp;raw); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">t.Agents = raw.Agents
                if len(raw.AdditionalTargets.JSON) &gt; 0 </span><span class="cov8" title="1">{
                        t.Additional = raw.AdditionalTargets
                }</span> else<span class="cov8" title="1"> {
                        t.Additional = raw.Additional
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unexpected targets format, expected sequence or mapping")</span>
        }
}

// IsZero reports whether any extra targets are configured.
func (e ExtraTargetsConfig) IsZero() bool <span class="cov8" title="1">{
        return len(e.Files) == 0 &amp;&amp; len(e.Directories) == 0
}</span>

// IsZero reports whether additional JSON targets are configured.
func (a AdditionalTargets) IsZero() bool <span class="cov0" title="0">{
        return len(a.JSON) == 0
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package syncer

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"
)

type Template struct {
        Name    string
        Payload string
}

// AgentConfig holds information about an agent's configuration file.
type AgentConfig struct {
        FilePath string // Path to the config file
        NodeName string // Name of the node where servers are stored
        Format   string // "json" or "toml"
}

// SupportedAgents returns a list of supported agent names.
func SupportedAgents() []string <span class="cov8" title="1">{
        return []string{"copilot", "vscode", "codex", "claudecode", "gemini"}
}</span>

// GetAgentConfig returns the configuration information for a given agent.
func GetAgentConfig(agent string) (AgentConfig, error) <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return AgentConfig{}, fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov8" title="1">switch normalizeAgent(agent) </span>{
        case "copilot":<span class="cov8" title="1">
                return AgentConfig{
                        FilePath: filepath.Join(homeDir, ".copilot", "mcp-config.json"),
                        NodeName: "mcpServers",
                        Format:   "json",
                }, nil</span>
        case "vscode":<span class="cov8" title="1">
                return AgentConfig{
                        FilePath: filepath.Join(homeDir, ".config", "Code", "User", "mcp.json"),
                        NodeName: "servers",
                        Format:   "json",
                }, nil</span>
        case "codex":<span class="cov8" title="1">
                return AgentConfig{
                        FilePath: filepath.Join(homeDir, ".codex", "config.toml"),
                        NodeName: "",
                        Format:   "toml",
                }, nil</span>
        case "claudecode":<span class="cov8" title="1">
                return AgentConfig{
                        FilePath: filepath.Join(homeDir, ".claude.json"),
                        NodeName: "mcpServers",
                        Format:   "json",
                }, nil</span>
        case "gemini":<span class="cov8" title="1">
                return AgentConfig{
                        FilePath: filepath.Join(homeDir, ".gemini", "settings.json"),
                        NodeName: "mcpServers",
                        Format:   "json",
                }, nil</span>
        default:<span class="cov8" title="1">
                return AgentConfig{}, fmt.Errorf("unsupported agent: %s", agent)</span>
        }
}

func LoadTemplateFromFile(path string) (Template, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return Template{}, err
        }</span>

        <span class="cov8" title="1">payload := strings.TrimSpace(string(data))
        return Template{
                Name:    filepath.Base(path),
                Payload: payload,
        }, nil</span>
}

type Syncer struct {
        SourceAgent string
        Agents      []string
}

func New(sourceAgent string, agents []string) *Syncer <span class="cov8" title="1">{
        normalized := normalizeAgent(sourceAgent)
        cleanAgents := uniqueAgents(agents)
        return &amp;Syncer{
                SourceAgent: normalized,
                Agents:      cleanAgents,
        }
}</span>

// SyncResult contains the output per agent plus the parsed server data.
type SyncResult struct {
        Agents  map[string]string
        Servers map[string]interface{}
}

func (s *Syncer) Sync(template Template) (SyncResult, error) <span class="cov8" title="1">{
        if strings.TrimSpace(template.Name) == "" </span><span class="cov0" title="0">{
                return SyncResult{}, fmt.Errorf("template requires a name")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(template.Payload) == "" </span><span class="cov8" title="1">{
                return SyncResult{}, fmt.Errorf("template payload cannot be empty")
        }</span>
        <span class="cov8" title="1">if _, err := GetAgentConfig(s.SourceAgent); err != nil </span><span class="cov8" title="1">{
                return SyncResult{}, fmt.Errorf("source agent %q not supported: %w", s.SourceAgent, err)
        }</span>

        <span class="cov8" title="1">servers, err := parseServersFromSource(s.SourceAgent, template.Payload)
        if err != nil </span><span class="cov0" title="0">{
                return SyncResult{}, err
        }</span>

        <span class="cov8" title="1">result := make(map[string]string, len(s.Agents))
        for _, agent := range s.Agents </span><span class="cov8" title="1">{
                result[agent] = formatConfig(agent, servers)
        }</span>

        <span class="cov8" title="1">return SyncResult{Agents: result, Servers: servers}, nil</span>
}

func formatConfig(agent string, servers map[string]interface{}) string <span class="cov8" title="1">{
        config, err := GetAgentConfig(agent)
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if config.Format == "toml" </span><span class="cov8" title="1">{
                return formatCodexConfig(config, servers)
        }</span>
        <span class="cov8" title="1">return formatToJSON(config.NodeName, servers)</span>
}

// parseServersFromSource extracts MCP server definitions from the source template
func parseServersFromSource(source, payload string) (map[string]interface{}, error) <span class="cov8" title="1">{
        sourceConfig, err := GetAgentConfig(source)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if sourceConfig.Format == "toml" </span><span class="cov8" title="1">{
                return parseServersFromTOML(payload)
        }</span>
        <span class="cov8" title="1">return parseServersFromJSON(sourceConfig.NodeName, payload)</span>
}

// parseServersFromJSON extracts servers from a JSON config
func parseServersFromJSON(nodeName, payload string) (map[string]interface{}, error) <span class="cov8" title="1">{
        var data map[string]interface{}
        if err := json.Unmarshal([]byte(payload), &amp;data); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse JSON: %w", err)
        }</span>

        // If nodeName is empty, assume the entire payload is the servers map
        <span class="cov8" title="1">if nodeName == "" </span><span class="cov8" title="1">{
                return data, nil
        }</span>

        <span class="cov8" title="1">servers, ok := data[nodeName].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                // Return empty map if node doesn't exist
                return make(map[string]interface{}), nil
        }</span>
        <span class="cov8" title="1">return servers, nil</span>
}

// parseServersFromTOML extracts servers from a TOML config (Codex format)
func parseServersFromTOML(payload string) (map[string]interface{}, error) <span class="cov8" title="1">{
        servers := make(map[string]interface{})
        lines := strings.Split(payload, "\n")

        var currentServer string
        var serverData map[string]interface{}

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check for server section header [mcp_servers.servername]
                <span class="cov8" title="1">if strings.HasPrefix(line, "[mcp_servers.") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov8" title="1">{
                        if currentServer != "" &amp;&amp; serverData != nil </span><span class="cov8" title="1">{
                                servers[currentServer] = serverData
                        }</span>
                        <span class="cov8" title="1">currentServer = strings.TrimPrefix(line, "[mcp_servers.")
                        currentServer = strings.TrimSuffix(currentServer, "]")
                        serverData = make(map[string]interface{})
                        continue</span>
                }

                // Parse key-value pairs within a server section
                <span class="cov8" title="1">if currentServer != "" &amp;&amp; strings.Contains(line, "=") </span><span class="cov8" title="1">{
                        parts := strings.SplitN(line, "=", 2)
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                key := strings.TrimSpace(parts[0])
                                value := strings.TrimSpace(parts[1])
                                // Handle string values
                                if strings.HasPrefix(value, "\"") &amp;&amp; strings.HasSuffix(value, "\"") </span><span class="cov8" title="1">{
                                        value = strings.Trim(value, "\"")
                                        serverData[key] = value
                                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(value, "[") </span><span class="cov8" title="1">{
                                        // Handle array values
                                        arr := parseTOMLArray(value)
                                        serverData[key] = arr
                                }</span> else<span class="cov8" title="1"> {
                                        serverData[key] = value
                                }</span>
                        }
                }
        }

        // Don't forget the last server
        <span class="cov8" title="1">if currentServer != "" &amp;&amp; serverData != nil </span><span class="cov8" title="1">{
                servers[currentServer] = serverData
        }</span>

        <span class="cov8" title="1">return servers, nil</span>
}

// parseTOMLArray parses a simple TOML array like ["a", "b", "c"]
// This handles basic quoted strings but does not support escaped quotes within values
func parseTOMLArray(value string) []string <span class="cov8" title="1">{
        value = strings.TrimPrefix(value, "[")
        value = strings.TrimSuffix(value, "]")
        value = strings.TrimSpace(value)

        if value == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var result []string
        var current strings.Builder
        inQuotes := false

        for i := 0; i &lt; len(value); i++ </span><span class="cov8" title="1">{
                ch := value[i]
                switch </span>{
                case ch == '"' &amp;&amp; !inQuotes:<span class="cov8" title="1">
                        inQuotes = true</span>
                case ch == '"' &amp;&amp; inQuotes:<span class="cov8" title="1">
                        inQuotes = false
                        result = append(result, current.String())
                        current.Reset()</span>
                case ch == ',' &amp;&amp; !inQuotes:<span class="cov8" title="1">
                        // Skip commas outside quotes (between elements)
                        continue</span>
                case inQuotes:<span class="cov8" title="1">
                        current.WriteByte(ch)</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// formatToJSON converts servers to JSON format with the specified node name
func formatToJSON(nodeName string, servers map[string]interface{}) string <span class="cov8" title="1">{
        var output map[string]interface{}
        if nodeName != "" </span><span class="cov8" title="1">{
                output = map[string]interface{}{
                        nodeName: servers,
                }
        }</span> else<span class="cov0" title="0"> {
                output = servers
        }</span>

        <span class="cov8" title="1">data, err := json.MarshalIndent(output, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return string(data)</span>
}

// formatToTOML converts servers to Codex TOML format
func formatToTOML(servers map[string]interface{}) string <span class="cov8" title="1">{
        var sb strings.Builder

        // Sort server names for consistent output
        names := make([]string, 0, len(servers))
        for name := range servers </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">sort.Strings(names)

        for _, name := range names </span><span class="cov8" title="1">{
                serverData, ok := servers[name].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("[mcp_servers.%s]\n", name))

                // Sort keys for consistent output
                keys := make([]string, 0, len(serverData))
                for k := range serverData </span><span class="cov8" title="1">{
                        keys = append(keys, k)
                }</span>
                <span class="cov8" title="1">sort.Strings(keys)

                for _, k := range keys </span><span class="cov8" title="1">{
                        v := serverData[k]
                        switch val := v.(type) </span>{
                        case string:<span class="cov8" title="1">
                                sb.WriteString(fmt.Sprintf("%s = \"%s\"\n", k, val))</span>
                        case []interface{}:<span class="cov8" title="1">
                                arr := make([]string, 0, len(val))
                                for _, item := range val </span><span class="cov8" title="1">{
                                        if s, ok := item.(string); ok </span><span class="cov8" title="1">{
                                                arr = append(arr, fmt.Sprintf("\"%s\"", s))
                                        }</span>
                                }
                                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%s = [%s]\n", k, strings.Join(arr, ", ")))</span>
                        case []string:<span class="cov8" title="1">
                                arr := make([]string, 0, len(val))
                                for _, s := range val </span><span class="cov8" title="1">{
                                        arr = append(arr, fmt.Sprintf("\"%s\"", s))
                                }</span>
                                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%s = [%s]\n", k, strings.Join(arr, ", ")))</span>
                        default:<span class="cov0" title="0">
                                sb.WriteString(fmt.Sprintf("%s = %v\n", k, val))</span>
                        }
                }
                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        <span class="cov8" title="1">return strings.TrimRight(sb.String(), "\n")</span>
}

func formatCodexConfig(cfg AgentConfig, servers map[string]interface{}) string <span class="cov8" title="1">{
        var existing string
        if data, err := os.ReadFile(cfg.FilePath); err == nil </span><span class="cov8" title="1">{
                existing = string(data)
        }</span>

        <span class="cov8" title="1">preserved := strings.TrimRight(stripMCPServersSections(existing), "\r\n")
        newSections := strings.TrimRight(formatToTOML(servers), "\r\n")

        var parts []string
        if preserved != "" </span><span class="cov8" title="1">{
                parts = append(parts, preserved)
        }</span>
        <span class="cov8" title="1">if newSections != "" </span><span class="cov8" title="1">{
                parts = append(parts, newSections)
        }</span>

        <span class="cov8" title="1">if len(parts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return strings.Join(parts, "\n\n") + "\n"</span>
}

func stripMCPServersSections(content string) string <span class="cov8" title="1">{
        if strings.TrimSpace(content) == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">lines := strings.Split(content, "\n")
        var sb strings.Builder
        insideMCP := false

        for i, line := range lines </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(line)
                if strings.HasPrefix(trimmed, "[") &amp;&amp; strings.HasSuffix(trimmed, "]") </span><span class="cov8" title="1">{
                        if strings.HasPrefix(trimmed, "[mcp_servers.") </span><span class="cov8" title="1">{
                                insideMCP = true
                                continue</span>
                        }
                        <span class="cov8" title="1">insideMCP = false</span>
                }
                <span class="cov8" title="1">if insideMCP </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">sb.WriteString(line)
                if i &lt; len(lines)-1 </span><span class="cov8" title="1">{
                        sb.WriteByte('\n')
                }</span>
        }

        <span class="cov8" title="1">return sb.String()</span>
}

func normalizeAgent(agent string) string <span class="cov8" title="1">{
        return strings.ToLower(strings.TrimSpace(agent))
}</span>

func uniqueAgents(agents []string) []string <span class="cov8" title="1">{
        seen := make(map[string]struct{}, len(agents))
        var out []string
        for _, agent := range agents </span><span class="cov8" title="1">{
                normalized := normalizeAgent(agent)
                if normalized == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, exists := seen[normalized]; exists </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[normalized] = struct{}{}
                out = append(out, normalized)</span>
        }
        <span class="cov8" title="1">return out</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
