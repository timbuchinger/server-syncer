
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent-align: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">agent-align/cmd/agent-align/additional.go (71.4%)</option>
				
				<option value="file1">agent-align/cmd/agent-align/extra_targets.go (73.7%)</option>
				
				<option value="file2">agent-align/cmd/agent-align/main.go (17.6%)</option>
				
				<option value="file3">agent-align/internal/config/config.go (66.0%)</option>
				
				<option value="file4">agent-align/internal/mcpconfig/mcpconfig.go (80.0%)</option>
				
				<option value="file5">agent-align/internal/syncer/syncer.go (70.1%)</option>
				
				<option value="file6">agent-align/internal/transforms/transforms.go (83.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "agent-align/internal/config"
)

func buildAdditionalJSONContent(target config.AdditionalJSONTarget, servers map[string]interface{}) (string, error) <span class="cov8" title="1">{
        pathSegments := jsonPathSegments(target.JSONPath)
        if len(pathSegments) == 0 </span><span class="cov8" title="1">{
                return marshalJSON(servers)
        }</span>

        <span class="cov8" title="1">root, err := loadJSONFile(target.FilePath)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">mergeJSONValue(root, pathSegments, servers)
        return marshalJSON(root)</span>
}

func loadJSONFile(path string) (map[string]interface{}, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return make(map[string]interface{}), nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read %s: %w", path, err)</span>
        }

        <span class="cov8" title="1">trimmed := strings.TrimSpace(string(data))
        if trimmed == "" </span><span class="cov0" title="0">{
                return make(map[string]interface{}), nil
        }</span>

        <span class="cov8" title="1">var out map[string]interface{}
        if err := json.Unmarshal(data, &amp;out); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse JSON from %s: %w", path, err)
        }</span>
        <span class="cov8" title="1">if out == nil </span><span class="cov0" title="0">{
                out = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func marshalJSON(value interface{}) (string, error) <span class="cov8" title="1">{
        data, err := json.MarshalIndent(value, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal JSON: %w", err)
        }</span>
        <span class="cov8" title="1">return string(data) + "\n", nil</span>
}

func mergeJSONValue(root map[string]interface{}, path []string, value interface{}) <span class="cov8" title="1">{
        current := root
        for i, segment := range path </span><span class="cov8" title="1">{
                if i == len(path)-1 </span><span class="cov8" title="1">{
                        current[segment] = value
                        return
                }</span>
                <span class="cov0" title="0">next, ok := current[segment].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        next = make(map[string]interface{})
                        current[segment] = next
                }</span>
                <span class="cov0" title="0">current = next</span>
        }
}

func jsonPathSegments(path string) []string <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(path)
        if trimmed == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">segments := strings.Split(trimmed, ".")
        var out []string
        for _, segment := range segments </span><span class="cov8" title="1">{
                if segment == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">out = append(out, segment)</span>
        }
        <span class="cov8" title="1">return out</span>
}

func displayJSONPath(path string) string <span class="cov0" title="0">{
        if trimmed := strings.TrimSpace(path); trimmed != "" </span><span class="cov0" title="0">{
                return trimmed
        }</span>
        <span class="cov0" title="0">return "&lt;root&gt;"</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "io"
        "io/fs"
        "os"
        "path/filepath"

        "agent-align/internal/config"
)

func copyExtraFileTarget(target config.ExtraFileTarget) error <span class="cov8" title="1">{
        info, err := os.Stat(target.Source)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to inspect %s: %w", target.Source, err)
        }</span>
        <span class="cov8" title="1">if info.IsDir() </span><span class="cov0" title="0">{
                return fmt.Errorf("extra file target %s is a directory; use directories instead", target.Source)
        }</span>
        <span class="cov8" title="1">for _, dest := range target.Destinations </span><span class="cov8" title="1">{
                if err := copyFileContents(target.Source, dest, info.Mode()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to copy %s to %s: %w", target.Source, dest, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func copyExtraDirectoryTarget(target config.ExtraDirectoryTarget) (int, error) <span class="cov8" title="1">{
        sourceInfo, err := os.Stat(target.Source)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to inspect %s: %w", target.Source, err)
        }</span>
        <span class="cov8" title="1">if !sourceInfo.IsDir() </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("extra directory target %s is not a directory", target.Source)
        }</span>

        <span class="cov8" title="1">var total int
        for _, dest := range target.Destinations </span><span class="cov8" title="1">{
                count, err := copyDirectory(target.Source, dest.Path, dest.Flatten)
                if err != nil </span><span class="cov0" title="0">{
                        return total, fmt.Errorf("failed to copy directory %s to %s: %w", target.Source, dest.Path, err)
                }</span>
                <span class="cov8" title="1">total += count</span>
        }
        <span class="cov8" title="1">return total, nil</span>
}

func copyDirectory(source, destination string, flatten bool) (int, error) <span class="cov8" title="1">{
        var copied int
        walkErr := filepath.WalkDir(source, func(path string, entry fs.DirEntry, walkErr error) error </span><span class="cov8" title="1">{
                if walkErr != nil </span><span class="cov0" title="0">{
                        return walkErr
                }</span>
                <span class="cov8" title="1">if entry.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">var destPath string
                if flatten </span><span class="cov8" title="1">{
                        destPath = filepath.Join(destination, filepath.Base(path))
                }</span> else<span class="cov8" title="1"> {
                        rel, err := filepath.Rel(source, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">destPath = filepath.Join(destination, rel)</span>
                }

                <span class="cov8" title="1">info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := copyFileContents(path, destPath, info.Mode()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">copied++
                return nil</span>
        })
        <span class="cov8" title="1">if walkErr != nil </span><span class="cov0" title="0">{
                return copied, walkErr
        }</span>
        <span class="cov8" title="1">return copied, nil</span>
}

func copyFileContents(source, dest string, mode os.FileMode) error <span class="cov8" title="1">{
        in, err := os.Open(source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer in.Close()

        if err := os.MkdirAll(filepath.Dir(dest), 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory for %s: %w", dest, err)
        }</span>

        <span class="cov8" title="1">out, err := os.OpenFile(dest, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, mode.Perm())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open %s: %w", dest, err)
        }</span>
        <span class="cov8" title="1">defer out.Close()

        if _, err := io.Copy(out, in); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy %s to %s: %w", source, dest, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "bufio"
        _ "embed"
        "errors"
        "flag"
        "fmt"
        "io"
        "log"
        "os"
        "path/filepath"
        "runtime"
        "sort"
        "strconv"
        "strings"
        "unicode"

        "gopkg.in/yaml.v3"

        "agent-align/internal/config"
        "agent-align/internal/mcpconfig"
        "agent-align/internal/syncer"
)

// version is set at build time via -ldflags.
var version = "dev"

var (
        promptUser    = askYes
        collectConfig = promptForConfig
)

//go:embed config.example.yml
var exampleConfig string

func main() <span class="cov0" title="0">{
        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == "init" </span><span class="cov0" title="0">{
                if err := runInitCommand(os.Args[2:]); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("init failed: %v", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">if err := validateCommand(os.Args); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">defaultAgents := strings.Join(syncer.SupportedAgents(), ",")
        agents := flag.String("agents", "", fmt.Sprintf("comma-separated list of agents to keep in sync (defaults to %s)", defaultAgents))
        configPath := flag.String("config", defaultConfigPath(), "path to YAML configuration file describing target agents and overrides")
        mcpConfigPath := flag.String("mcp-config", "", "path to YAML file that defines MCP servers (defaults to agent-align-mcp.yml next to the target config)")
        dryRun := flag.Bool("dry-run", false, "only show what would be changed without applying changes")
        debug := flag.Bool("debug", false, "print shell commands to test each MCP server and exit")
        confirm := flag.Bool("confirm", false, "skip user confirmation prompt (useful for cron jobs)")
        showVersion := flag.Bool("version", false, "print version and exit")

        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "agent-align version %s\n\n", version)
                fmt.Fprintf(os.Stderr, "Usage: agent-align [OPTIONS]\n\n")
                fmt.Fprintf(os.Stderr, "Options:\n")
                flag.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nDefault config file location: %s\n", defaultConfigPath())
                fmt.Fprintf(os.Stderr, "Default MCP config file location: %s\n", defaultMCPConfigPath(defaultConfigPath()))
                fmt.Fprintf(os.Stderr, "\nExample config file:\n%s\n", exampleConfig)
                fmt.Fprintf(os.Stderr, "Tip: add agent-align to cron for continuous syncing, e.g.:\n")
                fmt.Fprintf(os.Stderr, "  0 * * * * agent-align -confirm &gt;/tmp/agent-align.log 2&gt;&amp;1\n\n")
        }</span>

        <span class="cov0" title="0">flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                fmt.Printf("agent-align version %s\n", version)
                return
        }</span>

        <span class="cov0" title="0">resolvedConfigPath := *configPath
        resolvedMCPPath := strings.TrimSpace(*mcpConfigPath)
        agentsFlagValue := strings.TrimSpace(*agents)

        var cfg config.Config
        var haveConfig bool
        var additionalTargets []config.AdditionalJSONTarget
        var extraTargets config.ExtraTargetsConfig
        var targetAgents []syncer.AgentTarget

        if agentsFlagValue == "" </span><span class="cov0" title="0">{
                if err := ensureConfigFile(resolvedConfigPath); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("configuration unavailable: %v", err)
                }</span>
                <span class="cov0" title="0">data, err := config.Load(resolvedConfigPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to load config %q: %v", resolvedConfigPath, err)
                }</span>
                <span class="cov0" title="0">cfg = data
                haveConfig = true</span>
        } else<span class="cov0" title="0"> if _, err := os.Stat(resolvedConfigPath); err == nil </span><span class="cov0" title="0">{
                data, err := config.Load(resolvedConfigPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to load config %q: %v", resolvedConfigPath, err)
                }</span>
                <span class="cov0" title="0">cfg = data
                haveConfig = true</span>
        }

        <span class="cov0" title="0">if haveConfig </span><span class="cov0" title="0">{
                additionalTargets = cfg.MCP.Targets.Additional.JSON
                extraTargets = cfg.ExtraTargets
                targetAgents = configTargetsToSyncer(cfg.MCP.Targets.Agents)
                if resolvedMCPPath == "" </span><span class="cov0" title="0">{
                        resolvedMCPPath = cfg.MCP.ConfigPath
                }</span>
        }

        <span class="cov0" title="0">if resolvedMCPPath == "" </span><span class="cov0" title="0">{
                resolvedMCPPath = defaultMCPConfigPath(resolvedConfigPath)
        }</span>

        <span class="cov0" title="0">if agentsFlagValue != "" </span><span class="cov0" title="0">{
                names := parseAgents(agentsFlagValue)
                if len(names) == 0 </span><span class="cov0" title="0">{
                        log.Fatal("the -agents flag must list at least one agent")
                }</span>
                <span class="cov0" title="0">overrideLookup := make(map[string]string, len(cfg.MCP.Targets.Agents))
                for _, agent := range cfg.MCP.Targets.Agents </span><span class="cov0" title="0">{
                        overrideLookup[agent.Name] = agent.Path
                }</span>
                <span class="cov0" title="0">targetAgents = nil
                for _, name := range names </span><span class="cov0" title="0">{
                        normalized := strings.ToLower(strings.TrimSpace(name))
                        targetAgents = append(targetAgents, syncer.AgentTarget{
                                Name:         normalized,
                                PathOverride: overrideLookup[normalized],
                        })
                }</span>
        }

        <span class="cov0" title="0">if len(targetAgents) == 0 &amp;&amp; len(additionalTargets) == 0 &amp;&amp; extraTargets.IsZero() </span><span class="cov0" title="0">{
                log.Fatal("no target agents, additional destinations, or extra copy targets configured; provide agents via config/flags or add extra targets")
        }</span>

        <span class="cov0" title="0">servers, err := mcpconfig.Load(resolvedMCPPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to load MCP configuration %q: %v", resolvedMCPPath, err)
        }</span>

        // If debug flag is provided, print a shell-ready command for each server and exit.
        <span class="cov0" title="0">if *debug </span><span class="cov0" title="0">{
                printDebugCommands(servers)
                return
        }</span>

        <span class="cov0" title="0">s := syncer.New(targetAgents)

        syncResult, err := s.Sync(servers)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("sync failed: %v", err)
        }</span>

        // Display the dry run results
        <span class="cov0" title="0">fmt.Println("\n=== Dry Run Results ===")
        fmt.Println("The following configuration changes will be made:")
        fmt.Println()

        var agentNames []string
        for name := range syncResult.Agents </span><span class="cov0" title="0">{
                agentNames = append(agentNames, name)
        }</span>
        <span class="cov0" title="0">sort.Strings(agentNames)

        for _, agent := range agentNames </span><span class="cov0" title="0">{
                outputs := syncResult.Agents[agent]
                for _, output := range outputs </span><span class="cov0" title="0">{
                        fmt.Printf("Agent: %s\n", agent)
                        fmt.Printf("  File: %s\n", output.Config.FilePath)
                        fmt.Printf("  Format: %s\n", output.Config.Format)
                        fmt.Printf("  Content:\n")
                        // Indent the content for readability
                        lines := strings.Split(output.Content, "\n")
                        for _, line := range lines </span><span class="cov0" title="0">{
                                fmt.Printf("    %s\n", line)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }

        <span class="cov0" title="0">if len(additionalTargets) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Additional destinations:")
                for _, target := range additionalTargets </span><span class="cov0" title="0">{
                        fmt.Printf("Additional JSON: %s\n", target.FilePath)
                        fmt.Printf("  JSON Path: %s\n", displayJSONPath(target.JSONPath))
                        content, err := buildAdditionalJSONContent(target, syncResult.Servers)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("  (error preparing content: %v)\n\n", err)
                                continue</span>
                        }
                        <span class="cov0" title="0">content = strings.TrimRight(content, "\n")
                        if content == "" </span><span class="cov0" title="0">{
                                fmt.Println("  Content: &lt;empty&gt;")
                                fmt.Println()
                                continue</span>
                        }
                        <span class="cov0" title="0">fmt.Println("  Content:")
                        lines := strings.Split(content, "\n")
                        for _, line := range lines </span><span class="cov0" title="0">{
                                fmt.Printf("    %s\n", line)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }

        <span class="cov0" title="0">if !extraTargets.IsZero() </span><span class="cov0" title="0">{
                fmt.Println("Extra copy targets:")
                for _, target := range extraTargets.Files </span><span class="cov0" title="0">{
                        fmt.Printf("File Source: %s\n", target.Source)
                        for _, dest := range target.Destinations </span><span class="cov0" title="0">{
                                fmt.Printf("  -&gt; %s\n", dest)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
                <span class="cov0" title="0">for _, target := range extraTargets.Directories </span><span class="cov0" title="0">{
                        fmt.Printf("Directory Source: %s\n", target.Source)
                        fmt.Println("  Destinations:")
                        for _, dest := range target.Destinations </span><span class="cov0" title="0">{
                                label := dest.Path
                                if dest.Flatten </span><span class="cov0" title="0">{
                                        label = fmt.Sprintf("%s (flatten)", label)
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("    - %s\n", label)</span>
                        }
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }

        // If dry-run mode, exit without making changes
        <span class="cov0" title="0">if *dryRun </span><span class="cov0" title="0">{
                fmt.Println("Dry run complete. No changes were made.")
                return
        }</span>

        // If not in confirm mode, ask for user confirmation
        <span class="cov0" title="0">if !*confirm </span><span class="cov0" title="0">{
                if !promptUser("Apply these changes? [y/N]: ", false) </span><span class="cov0" title="0">{
                        fmt.Println("Changes cancelled.")
                        return
                }</span>
        }

        // Apply the changes
        <span class="cov0" title="0">fmt.Println("\nApplying changes...")
        var applyErrors []string
        for _, agent := range agentNames </span><span class="cov0" title="0">{
                outputs := syncResult.Agents[agent]
                for _, output := range outputs </span><span class="cov0" title="0">{
                        if err := writeAgentConfig(output.Config.FilePath, output.Content); err != nil </span><span class="cov0" title="0">{
                                msg := fmt.Sprintf("error writing config for %s: %v", agent, err)
                                log.Print(msg)
                                applyErrors = append(applyErrors, msg)
                                continue</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("  Updated: %s\n", output.Config.FilePath)</span>
                }
        }

        <span class="cov0" title="0">for _, target := range additionalTargets </span><span class="cov0" title="0">{
                content, err := buildAdditionalJSONContent(target, syncResult.Servers)
                if err != nil </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("error preparing additional JSON %s: %v", target.FilePath, err)
                        log.Print(msg)
                        applyErrors = append(applyErrors, msg)
                        continue</span>
                }
                <span class="cov0" title="0">if err := writeAgentConfig(target.FilePath, content); err != nil </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("error writing additional JSON %s: %v", target.FilePath, err)
                        log.Print(msg)
                        applyErrors = append(applyErrors, msg)
                        continue</span>
                }
                <span class="cov0" title="0">fmt.Printf("  Updated additional JSON: %s\n", target.FilePath)
                if target.JSONPath != "" </span><span class="cov0" title="0">{
                        fmt.Printf("    JSON Path: %s\n", target.JSONPath)
                }</span>
        }

        <span class="cov0" title="0">for _, target := range extraTargets.Files </span><span class="cov0" title="0">{
                if err := copyExtraFileTarget(target); err != nil </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("error copying extra file %s: %v", target.Source, err)
                        log.Print(msg)
                        applyErrors = append(applyErrors, msg)
                        continue</span>
                }
                <span class="cov0" title="0">fmt.Printf("  Copied extra file: %s -&gt; %d destinations\n", target.Source, len(target.Destinations))</span>
        }
        <span class="cov0" title="0">for _, target := range extraTargets.Directories </span><span class="cov0" title="0">{
                count, err := copyExtraDirectoryTarget(target)
                if err != nil </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("error copying extra directory %s: %v", target.Source, err)
                        log.Print(msg)
                        applyErrors = append(applyErrors, msg)
                        continue</span>
                }
                <span class="cov0" title="0">fmt.Printf("  Copied extra directory: %s -&gt; %d destination(s) (%d files)\n", target.Source, len(target.Destinations), count)
                var flattened bool
                for _, dest := range target.Destinations </span><span class="cov0" title="0">{
                        if dest.Flatten </span><span class="cov0" title="0">{
                                flattened = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if flattened </span><span class="cov0" title="0">{
                        fmt.Println("    Applied flatten to some destinations")
                }</span>
        }
        <span class="cov0" title="0">fmt.Println("\nConfiguration sync complete.")
        if len(applyErrors) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Encountered errors while applying changes:")
                for _, msg := range applyErrors </span><span class="cov0" title="0">{
                        fmt.Printf("  - %s\n", msg)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }
}

func parseAgents(agents string) []string <span class="cov8" title="1">{
        segments := strings.Split(agents, ",")
        var out []string
        for _, segment := range segments </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(segment)
                if trimmed == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">out = append(out, trimmed)</span>
        }
        <span class="cov8" title="1">return out</span>
}

func configTargetsToSyncer(targets []config.AgentTarget) []syncer.AgentTarget <span class="cov8" title="1">{
        out := make([]syncer.AgentTarget, 0, len(targets))
        for _, target := range targets </span><span class="cov8" title="1">{
                out = append(out, syncer.AgentTarget{
                        Name:               target.Name,
                        PathOverride:       target.Path,
                        DisabledMcpServers: target.DisabledMcpServers,
                })
        }</span>
        <span class="cov8" title="1">return out</span>
}

func defaultConfigPath() string <span class="cov8" title="1">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                return "/usr/local/etc/agent-align.yml"</span>
        case "windows":<span class="cov0" title="0">
                if base := os.Getenv("ProgramData"); base != "" </span><span class="cov0" title="0">{
                        return filepath.Join(base, "agent-align", "config.yml")
                }</span>
                <span class="cov0" title="0">return `C:\ProgramData\agent-align\config.yml`</span>
        default:<span class="cov8" title="1">
                return "/etc/agent-align.yml"</span>
        }
}

func defaultMCPConfigPath(configPath string) string <span class="cov8" title="1">{
        dir := filepath.Dir(configPath)
        if dir == "" </span><span class="cov0" title="0">{
                return "agent-align-mcp.yml"
        }</span>
        <span class="cov8" title="1">return filepath.Join(dir, "agent-align-mcp.yml")</span>
}

func ensureConfigFile(path string) error <span class="cov8" title="1">{
        if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov8" title="1"> if !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to inspect %q: %w", path, err)
        }</span>

        <span class="cov8" title="1">prompt := fmt.Sprintf("Configuration %s not found. %sCreate a default config? [Y/n]: ", path, configPromptSuffix(path))
        if !promptUser(prompt, true) </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration file %s is required", path)
        }</span>

        <span class="cov8" title="1">cfg, err := collectConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to collect configuration: %w", err)
        }</span>
        <span class="cov8" title="1">if err := writeConfigFile(path, cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">fmt.Printf("Created configuration file at %s\n", path)
        return nil</span>
}

func runInitCommand(args []string) error <span class="cov0" title="0">{
        initFlags := flag.NewFlagSet("init", flag.ExitOnError)
        configPath := initFlags.String("config", defaultConfigPath(), "path to YAML configuration file to create")
        if err := initFlags.Parse(args); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">path := *configPath
        if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                if !promptUser(fmt.Sprintf("Configuration already exists at %s. Overwrite? [y/N]: ", path), false) </span><span class="cov0" title="0">{
                        fmt.Println("Init cancelled.")
                        return nil
                }</span>
        } else<span class="cov0" title="0"> if !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to inspect %q: %w", path, err)
        }</span>

        <span class="cov0" title="0">cfg, err := collectConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to collect configuration: %w", err)
        }</span>
        <span class="cov0" title="0">if err := writeConfigFile(path, cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("Created configuration file at %s\n", path)
        return nil</span>
}

func askYes(prompt string, defaultYes bool) bool <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        for </span><span class="cov0" title="0">{
                fmt.Print(prompt)
                input, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return defaultYes
                }</span>

                <span class="cov0" title="0">response := strings.TrimSpace(strings.ToLower(input))
                if response == "" </span><span class="cov0" title="0">{
                        return defaultYes
                }</span>

                <span class="cov0" title="0">switch response </span>{
                case "y", "yes":<span class="cov0" title="0">
                        return true</span>
                case "n", "no":<span class="cov0" title="0">
                        return false</span>
                default:<span class="cov0" title="0">
                        fmt.Println("Please answer 'y' or 'n'.")</span>
                }
        }
}

func promptForConfig() (config.Config, error) <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        fmt.Println("\nLet's create your agent-align configuration.")
        targets, err := promptTargetAgents(reader)
        if err != nil </span><span class="cov0" title="0">{
                return config.Config{}, err
        }</span>
        <span class="cov0" title="0">additionalJSON, err := promptAdditionalJSONTargets(reader)
        if err != nil </span><span class="cov0" title="0">{
                return config.Config{}, err
        }</span>
        <span class="cov0" title="0">additional := config.AdditionalTargets{}
        if len(additionalJSON) &gt; 0 </span><span class="cov0" title="0">{
                additional.JSON = additionalJSON
        }</span>
        <span class="cov0" title="0">return config.Config{
                MCP: config.MCPConfig{
                        Targets: config.TargetsConfig{
                                Agents:     targets,
                                Additional: additional,
                        },
                },
        }, nil</span>
}

func configPromptSuffix(path string) string <span class="cov8" title="1">{
        if path == defaultConfigPath() </span><span class="cov0" title="0">{
                return "Use -config to choose another path. "
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func promptTargetAgents(reader *bufio.Reader) ([]config.AgentTarget, error) <span class="cov8" title="1">{
        options := syncer.SupportedAgents()

        sort.Strings(options)
        fmt.Println("\nSelect target agents (enter comma-separated numbers, e.g. 1,3):")
        for i, agent := range options </span><span class="cov8" title="1">{
                fmt.Printf("  %d) %s\n", i+1, agent)
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                fmt.Print("Enter one or more choices: ")
                line, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">selections, parseErr := parseSelectionIndices(line)
                if parseErr != nil </span><span class="cov0" title="0">{
                        fmt.Println(parseErr)
                        continue</span>
                }
                <span class="cov8" title="1">seen := make(map[int]struct{}, len(selections))
                var targets []config.AgentTarget
                valid := true
                for _, idx := range selections </span><span class="cov8" title="1">{
                        if idx &lt; 1 || idx &gt; len(options) </span><span class="cov8" title="1">{
                                fmt.Printf("Selection %d is out of range. Please use numbers from the list.\n", idx)
                                valid = false
                                break</span>
                        }
                        <span class="cov8" title="1">if _, exists := seen[idx]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">seen[idx] = struct{}{}
                        targets = append(targets, config.AgentTarget{Name: options[idx-1]})</span>
                }
                <span class="cov8" title="1">if !valid </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if len(targets) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("Please select at least one target agent.")
                        continue</span>
                }
                <span class="cov8" title="1">return targets, nil</span>
        }
}

func parseSelectionIndices(input string) ([]int, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(input)
        if trimmed == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Please enter at least one selection.")
        }</span>
        <span class="cov8" title="1">segments := strings.FieldsFunc(trimmed, func(r rune) bool </span><span class="cov8" title="1">{
                return r == ',' || unicode.IsSpace(r)
        }</span>)
        <span class="cov8" title="1">if len(segments) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Please enter at least one selection.")
        }</span>
        <span class="cov8" title="1">var selections []int
        for _, segment := range segments </span><span class="cov8" title="1">{
                value, err := strconv.Atoi(segment)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%q is not a valid number", segment)
                }</span>
                <span class="cov8" title="1">selections = append(selections, value)</span>
        }
        <span class="cov8" title="1">return selections, nil</span>
}

func promptAdditionalJSONTargets(reader *bufio.Reader) ([]config.AdditionalJSONTarget, error) <span class="cov0" title="0">{
        fmt.Println("\nAdd optional MCP destinations (custom files outside the built-in agents).")
        var targets []config.AdditionalJSONTarget

        for </span><span class="cov0" title="0">{
                addMore, err := promptYesNoInput(reader, "Add an additional JSON destination? [y/N]: ", false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if !addMore </span><span class="cov0" title="0">{
                        return targets, nil
                }</span>

                <span class="cov0" title="0">filePath, err := promptRequiredValue(reader, "Enter the destination file path: ", "Please enter a file path.")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">jsonPath, err := promptRequiredValue(reader, "Enter the JSON path within that file (e.g. .mcpServers): ", "Please enter a JSON path.")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">targets = append(targets, config.AdditionalJSONTarget{
                        FilePath: filePath,
                        JSONPath: jsonPath,
                })</span>
        }
}

func promptYesNoInput(reader *bufio.Reader, prompt string, defaultYes bool) (bool, error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                fmt.Print(prompt)
                input, err := reader.ReadString('\n')
                if err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov0" title="0">response := strings.TrimSpace(strings.ToLower(input))
                if response == "" </span><span class="cov0" title="0">{
                        return defaultYes, nil
                }</span>

                <span class="cov0" title="0">switch response </span>{
                case "y", "yes":<span class="cov0" title="0">
                        return true, nil</span>
                case "n", "no":<span class="cov0" title="0">
                        return false, nil</span>
                default:<span class="cov0" title="0">
                        fmt.Println("Please answer 'y' or 'n'.")
                        if err != nil &amp;&amp; errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                                return defaultYes, nil
                        }</span>
                }
        }
}

func promptRequiredValue(reader *bufio.Reader, prompt, emptyMsg string) (string, error) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                fmt.Print(prompt)
                input, err := reader.ReadString('\n')
                if err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">value := strings.TrimSpace(input)
                if value == "" </span><span class="cov0" title="0">{
                        fmt.Println(emptyMsg)
                        if err != nil &amp;&amp; errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                                return "", errors.New(emptyMsg)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                <span class="cov0" title="0">return value, nil</span>
        }
}

func writeConfigFile(path string, cfg config.Config) error <span class="cov8" title="1">{
        data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate config contents: %w", err)
        }</span>
        <span class="cov8" title="1">dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure directory %q: %w", dir, err)
        }</span>
        <span class="cov8" title="1">if err := os.WriteFile(path, data, 0o644); err != nil </span><span class="cov0" title="0">{
                printManualConfigInstructions(path, data)
                return fmt.Errorf("failed to write config %q: %w", path, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func printManualConfigInstructions(path string, contents []byte) <span class="cov0" title="0">{
        fmt.Fprintf(os.Stderr, "\nUnable to write the config file automatically. Please create %s with the following contents:\n\n%s\n", path, contents)
}</span>

func writeAgentConfig(path, content string) error <span class="cov0" title="0">{
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure directory %q: %w", dir, err)
        }</span>
        <span class="cov0" title="0">if err := os.WriteFile(path, []byte(content), 0o644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config %q: %w", path, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateCommand(args []string) error <span class="cov8" title="1">{
        if len(args) &lt;= 1 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">arg := args[1]
        if arg == "" || arg == "init" || strings.HasPrefix(arg, "-") </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("unknown command %q. Use -h for usage or run \"init\" to create a config.", arg)</span>
}

// printDebugCommands emits a shell-ready test command for every MCP server definition
// found in the provided map and prints them to stdout.
func printDebugCommands(servers map[string]interface{}) <span class="cov0" title="0">{
        var names []string
        for name := range servers </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">sort.Strings(names)
        for _, name := range names </span><span class="cov0" title="0">{
                serverRaw := servers[name]
                m, ok := serverRaw.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        // skip unexpected shapes
                        continue</span>
                }
                <span class="cov0" title="0">cmd := formatServerCommand(m)
                if cmd == "" </span><span class="cov0" title="0">{
                        fmt.Printf("%s: &lt;cannot render command&gt;\n", name)
                        continue</span>
                }
                <span class="cov0" title="0">fmt.Printf("%s: %s\n", name, cmd)</span>
        }
}

// formatServerCommand builds a single-line shell command for a server mapping.
// It concatenates environment assignments (KEY=VALUE) before the command and
// properly quotes arguments.
func formatServerCommand(m map[string]interface{}) string <span class="cov0" title="0">{
        // command
        cmdVal, ok := m["command"]
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">cmdStr, ok := cmdVal.(string)
        if !ok || strings.TrimSpace(cmdStr) == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        // args may be an array
        <span class="cov0" title="0">var args []string
        if rawArgs, ok := m["args"]; ok </span><span class="cov0" title="0">{
                switch v := rawArgs.(type) </span>{
                case []interface{}:<span class="cov0" title="0">
                        for _, ai := range v </span><span class="cov0" title="0">{
                                if s, ok := ai.(string); ok </span><span class="cov0" title="0">{
                                        args = append(args, s)
                                }</span>
                        }
                case []string:<span class="cov0" title="0">
                        args = append(args, v...)</span>
                case string:<span class="cov0" title="0">
                        // single string argument
                        args = append(args, v)</span>
                }
        }

        // env may be a map
        <span class="cov0" title="0">var envParts []string
        if rawEnv, ok := m["env"]; ok </span><span class="cov0" title="0">{
                if envMap, ok := rawEnv.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // preserve insertion order by sorting keys
                        var keys []string
                        for k := range envMap </span><span class="cov0" title="0">{
                                keys = append(keys, k)
                        }</span>
                        <span class="cov0" title="0">sort.Strings(keys)
                        for _, k := range keys </span><span class="cov0" title="0">{
                                v := envMap[k]
                                sval := fmt.Sprintf("%v", v)
                                // if value looks like ${VAR} or starts with $ keep as-is
                                if (strings.HasPrefix(sval, "${") &amp;&amp; strings.HasSuffix(sval, "}")) || strings.HasPrefix(sval, "$") </span><span class="cov0" title="0">{
                                        envParts = append(envParts, fmt.Sprintf("%s=%s", k, sval))
                                }</span> else<span class="cov0" title="0"> {
                                        envParts = append(envParts, fmt.Sprintf("%s=%s", k, shellQuote(sval)))
                                }</span>
                        }
                }
        }

        // build full command
        <span class="cov0" title="0">var parts []string
        if len(envParts) &gt; 0 </span><span class="cov0" title="0">{
                parts = append(parts, strings.Join(envParts, " "))
        }</span>
        // quote the command itself if needed
        <span class="cov0" title="0">parts = append(parts, shellQuote(cmdStr))
        for _, a := range args </span><span class="cov0" title="0">{
                parts = append(parts, shellQuote(a))
        }</span>
        <span class="cov0" title="0">return strings.Join(parts, " ")</span>
}

// shellQuote applies simple single-quote quoting suitable for POSIX shells.
// If the string already looks like a shell variable reference (starts with $ or ${...})
// it is returned unchanged.
func shellQuote(s string) string <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return "''"
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(s, "${") &amp;&amp; strings.HasSuffix(s, "}") </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(s, "$") </span><span class="cov0" title="0">{
                return s
        }</span>
        // safe characters: alphanum, ./@-_:+=, don't quote
        <span class="cov0" title="0">safe := true
        for _, r := range s </span><span class="cov0" title="0">{
                if !(r == '.' || r == '/' || r == '@' || r == '-' || r == '_' || r == ':' || r == '+' || r == '=' || (r &gt;= '0' &amp;&amp; r &lt;= '9') || (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') || (r &gt;= 'a' &amp;&amp; r &lt;= 'z')) </span><span class="cov0" title="0">{
                        safe = false
                        break</span>
                }
        }
        <span class="cov0" title="0">if safe </span><span class="cov0" title="0">{
                return s
        }</span>
        // escape single quotes by closing, inserting '\'' and reopening
        <span class="cov0" title="0">escaped := strings.ReplaceAll(s, "'", "'\\''")
        return "'" + escaped + "'"</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "gopkg.in/yaml.v3"
)

// Config describes the MCP sync behavior and extra file/directory copies.
type Config struct {
        MCP          MCPConfig          `yaml:"mcpServers"`
        ExtraTargets ExtraTargetsConfig `yaml:"extraTargets"`
}

// MCPConfig groups the MCP definition source and the target agents.
type MCPConfig struct {
        ConfigPath string        `yaml:"configPath"`
        Targets    TargetsConfig `yaml:"targets"`
}

// TargetsConfig groups agent targets and additional destinations.
type TargetsConfig struct {
        Agents     []AgentTarget     `yaml:"agents"`
        Additional AdditionalTargets `yaml:"additionalTargets"`
}

// AgentTarget allows overriding the destination path for an agent.
type AgentTarget struct {
        Name string `yaml:"name"`
        Path string `yaml:"path,omitempty"`
        // DisabledMcpServers lists MCP IDs that should be omitted for this agent.
        DisabledMcpServers []string `yaml:"disabledMcpServers,omitempty"`
}

// AdditionalTargets lists paths for JSON-style destinations.
type AdditionalTargets struct {
        JSON []AdditionalJSONTarget `yaml:"json"`
}

// ExtraTargetsConfig describes file/directory copy operations outside the MCP sync.
type ExtraTargetsConfig struct {
        Files       []ExtraFileTarget      `yaml:"files"`
        Directories []ExtraDirectoryTarget `yaml:"directories"`
}

// ExtraFileTarget copies a single source file into multiple destinations.
type ExtraFileTarget struct {
        Source       string   `yaml:"source"`
        Destinations []string `yaml:"destinations"`
}

// ExtraDirectoryTarget copies an entire directory, optionally flattening the files.
type ExtraDirectoryTarget struct {
        Source       string                    `yaml:"source"`
        Destinations []ExtraDirectoryCopyRoute `yaml:"destinations"`
}

// ExtraDirectoryCopyRoute describes how a single destination should be written.
type ExtraDirectoryCopyRoute struct {
        Path    string `yaml:"path"`
        Flatten bool   `yaml:"flatten"`
}

// AdditionalJSONTarget describes a JSON file that should receive the MCP payload.
type AdditionalJSONTarget struct {
        FilePath string `yaml:"filePath"`
        JSONPath string `yaml:"jsonPath"`
}

// UnmarshalYAML lets agent targets be provided as either strings or mappings.
func (a *AgentTarget) UnmarshalYAML(node *yaml.Node) error <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">switch node.Kind </span>{
        case yaml.ScalarNode:<span class="cov8" title="1">
                var name string
                if err := node.Decode(&amp;name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">a.Name = name
                return nil</span>
        case yaml.MappingNode:<span class="cov8" title="1">
                type raw AgentTarget
                var r raw
                if err := node.Decode(&amp;r); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">a.Name = r.Name
                a.Path = r.Path
                a.DisabledMcpServers = r.DisabledMcpServers
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("agent entry must be a string or mapping")</span>
        }
}

// UnmarshalYAML accepts both a sequence of agents and a mapping with additional targets.
func (t *TargetsConfig) UnmarshalYAML(node *yaml.Node) error <span class="cov8" title="1">{
        if node == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">switch node.Kind </span>{
        case yaml.SequenceNode:<span class="cov0" title="0">
                var agents []AgentTarget
                if err := node.Decode(&amp;agents); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">t.Agents = agents
                return nil</span>
        case yaml.MappingNode:<span class="cov8" title="1">
                type raw struct {
                        Agents            []AgentTarget     `yaml:"agents"`
                        Additional        AdditionalTargets `yaml:"additional"`
                        AdditionalTargets AdditionalTargets `yaml:"additionalTargets"`
                }
                var r raw
                if err := node.Decode(&amp;r); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">t.Agents = r.Agents
                if len(r.AdditionalTargets.JSON) &gt; 0 </span><span class="cov8" title="1">{
                        t.Additional = r.AdditionalTargets
                }</span> else<span class="cov8" title="1"> {
                        t.Additional = r.Additional
                }</span>
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unexpected targets format, expected sequence or mapping")</span>
        }
}

// Load reads the YAML configuration from the given path and validates it.
func Load(path string) (Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return Config{}, err
        }</span>

        <span class="cov8" title="1">var cfg Config
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov8" title="1">{
                return Config{}, fmt.Errorf("failed to parse config at %q: %w", path, err)
        }</span>

        <span class="cov8" title="1">cfg.MCP.ConfigPath = strings.TrimSpace(cfg.MCP.ConfigPath)
        if cfg.MCP.ConfigPath != "" </span><span class="cov8" title="1">{
                expanded, err := expandUserPath(cfg.MCP.ConfigPath)
                if err != nil </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an invalid MCP configPath %q: %w", path, cfg.MCP.ConfigPath, err)
                }</span>
                <span class="cov8" title="1">cfg.MCP.ConfigPath = expanded</span>
        }

        <span class="cov8" title="1">cfg.MCP.Targets = normalizeTargets(cfg.MCP.Targets)

        for i := range cfg.MCP.Targets.Additional.JSON </span><span class="cov8" title="1">{
                cfg.MCP.Targets.Additional.JSON[i].FilePath = strings.TrimSpace(cfg.MCP.Targets.Additional.JSON[i].FilePath)
                cfg.MCP.Targets.Additional.JSON[i].JSONPath = strings.TrimSpace(cfg.MCP.Targets.Additional.JSON[i].JSONPath)
                if cfg.MCP.Targets.Additional.JSON[i].FilePath == "" </span><span class="cov8" title="1">{
                        return Config{}, fmt.Errorf("config at %q has an additional JSON target without a filePath", path)
                }</span>
                <span class="cov8" title="1">expanded, err := expandUserPath(cfg.MCP.Targets.Additional.JSON[i].FilePath)
                if err != nil </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an additional JSON target with invalid filePath %q: %w", path, cfg.MCP.Targets.Additional.JSON[i].FilePath, err)
                }</span>
                <span class="cov8" title="1">cfg.MCP.Targets.Additional.JSON[i].FilePath = expanded</span>
        }

        <span class="cov8" title="1">for i := range cfg.ExtraTargets.Files </span><span class="cov8" title="1">{
                source := strings.TrimSpace(cfg.ExtraTargets.Files[i].Source)
                if source == "" </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an extra file target without a source", path)
                }</span>
                <span class="cov8" title="1">expandedSource, err := expandUserPath(source)
                if err != nil </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an extra file target with invalid source %q: %w", path, source, err)
                }</span>
                <span class="cov8" title="1">cfg.ExtraTargets.Files[i].Source = expandedSource
                var dests []string
                for _, dest := range cfg.ExtraTargets.Files[i].Destinations </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(dest)
                        if trimmed == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">expandedDest, err := expandUserPath(trimmed)
                        if err != nil </span><span class="cov0" title="0">{
                                return Config{}, fmt.Errorf("config at %q has an extra file target destination %q: %w", path, trimmed, err)
                        }</span>
                        <span class="cov8" title="1">dests = append(dests, expandedDest)</span>
                }
                <span class="cov8" title="1">if len(dests) == 0 </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an extra file target for %q without destinations", path, source)
                }</span>
                <span class="cov8" title="1">cfg.ExtraTargets.Files[i].Destinations = dests</span>
        }

        <span class="cov8" title="1">for i := range cfg.ExtraTargets.Directories </span><span class="cov0" title="0">{
                source := strings.TrimSpace(cfg.ExtraTargets.Directories[i].Source)
                if source == "" </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an extra directory target without a source", path)
                }</span>
                <span class="cov0" title="0">expandedSource, err := expandUserPath(source)
                if err != nil </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an extra directory target with invalid source %q: %w", path, source, err)
                }</span>
                <span class="cov0" title="0">cfg.ExtraTargets.Directories[i].Source = expandedSource
                var routes []ExtraDirectoryCopyRoute
                for _, dest := range cfg.ExtraTargets.Directories[i].Destinations </span><span class="cov0" title="0">{
                        trimmed := strings.TrimSpace(dest.Path)
                        if trimmed == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">expandedPath, err := expandUserPath(trimmed)
                        if err != nil </span><span class="cov0" title="0">{
                                return Config{}, fmt.Errorf("config at %q has an extra directory destination %q: %w", path, trimmed, err)
                        }</span>
                        <span class="cov0" title="0">routes = append(routes, ExtraDirectoryCopyRoute{
                                Path:    expandedPath,
                                Flatten: dest.Flatten,
                        })</span>
                }
                <span class="cov0" title="0">if len(routes) == 0 </span><span class="cov0" title="0">{
                        return Config{}, fmt.Errorf("config at %q has an extra directory target for %q without destinations", path, source)
                }</span>
                <span class="cov0" title="0">cfg.ExtraTargets.Directories[i].Destinations = routes</span>
        }

        <span class="cov8" title="1">if len(cfg.MCP.Targets.Agents) == 0 &amp;&amp;
                len(cfg.MCP.Targets.Additional.JSON) == 0 &amp;&amp;
                cfg.ExtraTargets.IsZero() </span><span class="cov8" title="1">{
                return Config{}, fmt.Errorf("config at %q must define at least one target", path)
        }</span>

        <span class="cov8" title="1">return cfg, nil</span>
}

func normalizeAgent(value string) string <span class="cov8" title="1">{
        return strings.ToLower(strings.TrimSpace(value))
}</span>

func normalizeTargets(targets TargetsConfig) TargetsConfig <span class="cov8" title="1">{
        seen := make(map[string]struct{}, len(targets.Agents))
        var agents []AgentTarget
        for _, target := range targets.Agents </span><span class="cov8" title="1">{
                name := normalizeAgent(target.Name)
                if name == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">path := strings.TrimSpace(target.Path)
                if path != "" </span><span class="cov8" title="1">{
                        expanded, err := expandUserPath(path)
                        if err == nil </span><span class="cov8" title="1">{
                                path = expanded
                        }</span>
                }
                // Normalize disabled MCP list: trim entries and skip empty
                <span class="cov8" title="1">var disabled []string
                for _, d := range target.DisabledMcpServers </span><span class="cov0" title="0">{
                        t := strings.TrimSpace(d)
                        if t == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">disabled = append(disabled, t)</span>
                }
                <span class="cov8" title="1">key := name + "|" + path + "|" + strings.Join(disabled, ",")
                if _, exists := seen[key]; exists </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[key] = struct{}{}
                agents = append(agents, AgentTarget{
                        Name:               name,
                        Path:               path,
                        DisabledMcpServers: disabled,
                })</span>
        }
        <span class="cov8" title="1">targets.Agents = agents
        return targets</span>
}

func expandUserPath(value string) (string, error) <span class="cov8" title="1">{
        value = strings.TrimSpace(value)
        if value == "" || value[0] != '~' </span><span class="cov0" title="0">{
                return value, nil
        }</span>
        <span class="cov8" title="1">home, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("resolve home directory: %w", err)
        }</span>
        <span class="cov8" title="1">if len(value) == 1 </span><span class="cov0" title="0">{
                return home, nil
        }</span>
        <span class="cov8" title="1">switch value[1] </span>{
        case '/', '\\':<span class="cov8" title="1">
                remainder := strings.TrimLeft(value[1:], "/\\")
                if remainder == "" </span><span class="cov0" title="0">{
                        return home, nil
                }</span>
                <span class="cov8" title="1">return filepath.Clean(filepath.Join(home, remainder)), nil</span>
        default:<span class="cov0" title="0">
                return value, nil</span>
        }
}

// IsZero reports whether any extra targets are configured.
func (e ExtraTargetsConfig) IsZero() bool <span class="cov8" title="1">{
        return len(e.Files) == 0 &amp;&amp; len(e.Directories) == 0
}</span>

// IsZero reports whether additional JSON targets are configured.
func (a AdditionalTargets) IsZero() bool <span class="cov8" title="1">{
        return len(a.JSON) == 0
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package mcpconfig

import (
        "fmt"
        "os"

        "gopkg.in/yaml.v3"
)

// Load reads the MCP server definitions from a YAML file.
// It accepts either a top-level "servers" or "mcpServers" mapping.
func Load(path string) (map[string]interface{}, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var raw struct {
                Servers    map[string]interface{} `yaml:"servers"`
                MCPServers map[string]interface{} `yaml:"mcpServers"`
        }
        if err := yaml.Unmarshal(data, &amp;raw); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse MCP config at %q: %w", path, err)
        }</span>

        <span class="cov8" title="1">servers := raw.Servers
        if len(servers) == 0 </span><span class="cov8" title="1">{
                servers = raw.MCPServers
        }</span>
        <span class="cov8" title="1">if len(servers) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no MCP servers found in %s", path)
        }</span>

        <span class="cov8" title="1">for name, server := range servers </span><span class="cov8" title="1">{
                if _, ok := server.(map[string]interface{}); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("server %q must be a mapping", name)
                }</span>
        }

        <span class="cov8" title="1">return servers, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package syncer

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "runtime"
        "sort"
        "strings"

        "agent-align/internal/transforms"
)

// AgentTarget allows overrides for an agent destination.
type AgentTarget struct {
        Name         string
        PathOverride string
        // DisabledMcpServers lists MCP IDs that should be omitted for this agent.
        DisabledMcpServers []string
}

// AgentConfig holds information about an agent's configuration file.
type AgentConfig struct {
        Name     string // Normalized agent name
        FilePath string // Path to the config file
        NodeName string // Name of the node where servers are stored
        Format   string // "json" or "toml"
}

// AgentResult is the rendered output for a single agent.
type AgentResult struct {
        Config  AgentConfig
        Content string
}

var supportedAgentList = []string{"copilot", "vscode", "codex", "claudecode", "gemini", "kilocode"}

// SupportedAgents returns a list of supported agent names.
func SupportedAgents() []string <span class="cov8" title="1">{
        return append([]string(nil), supportedAgentList...)
}</span>

// GetAgentConfig returns the configuration information for a given agent.
func GetAgentConfig(agent, overridePath string) (AgentConfig, error) <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return AgentConfig{}, fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov8" title="1">name := normalizeAgent(agent)
        switch name </span>{
        case "copilot":<span class="cov8" title="1">
                return AgentConfig{
                        Name:     name,
                        FilePath: applyOverride(overridePath, filepath.Join(homeDir, ".copilot", "mcp-config.json")),
                        NodeName: "mcpServers",
                        Format:   "json",
                }, nil</span>
        case "vscode":<span class="cov8" title="1">
                return AgentConfig{
                        Name:     name,
                        FilePath: applyOverride(overridePath, filepath.Join(homeDir, ".config", "Code", "User", "mcp.json")),
                        NodeName: "servers",
                        Format:   "json",
                }, nil</span>
        case "codex":<span class="cov8" title="1">
                return AgentConfig{
                        Name:     name,
                        FilePath: applyOverride(overridePath, filepath.Join(homeDir, ".codex", "config.toml")),
                        NodeName: "",
                        Format:   "toml",
                }, nil</span>
        case "claudecode":<span class="cov0" title="0">
                return AgentConfig{
                        Name:     name,
                        FilePath: applyOverride(overridePath, filepath.Join(homeDir, ".claude.json")),
                        NodeName: "mcpServers",
                        Format:   "json",
                }, nil</span>
        case "gemini":<span class="cov0" title="0">
                return AgentConfig{
                        Name:     name,
                        FilePath: applyOverride(overridePath, filepath.Join(homeDir, ".gemini", "settings.json")),
                        NodeName: "mcpServers",
                        Format:   "json",
                }, nil</span>
        case "kilocode":<span class="cov0" title="0">
                var defaultPath string
                if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                        defaultPath = filepath.Join(homeDir, "AppData", "Roaming", "Code", "user", "mcp.json")
                }</span> else<span class="cov0" title="0"> {
                        defaultPath = filepath.Join(homeDir, ".config", "Code", "User", "globalStorage", "kilocode.kilo-code", "settings", "mcp_settings.json")
                }</span>
                <span class="cov0" title="0">return AgentConfig{
                        Name:     name,
                        FilePath: applyOverride(overridePath, defaultPath),
                        NodeName: "mcpServers",
                        Format:   "json",
                }, nil</span>
        default:<span class="cov0" title="0">
                return AgentConfig{}, fmt.Errorf("unsupported agent: %s", agent)</span>
        }
}

// Syncer renders MCP server definitions into the supported agent formats.
type Syncer struct {
        Agents []AgentTarget
}

func New(agents []AgentTarget) *Syncer <span class="cov8" title="1">{
        return &amp;Syncer{Agents: dedupeTargets(agents)}
}</span>

// SyncResult contains the output per agent plus the parsed server data.
type SyncResult struct {
        Agents  map[string][]AgentResult
        Servers map[string]interface{}
}

func (s *Syncer) Sync(servers map[string]interface{}) (SyncResult, error) <span class="cov8" title="1">{
        if len(servers) == 0 </span><span class="cov0" title="0">{
                return SyncResult{}, fmt.Errorf("server list cannot be empty")
        }</span>

        <span class="cov8" title="1">outputs := make(map[string][]AgentResult, len(s.Agents))
        for _, agent := range s.Agents </span><span class="cov8" title="1">{
                cfg, err := GetAgentConfig(agent.Name, agent.PathOverride)
                if err != nil </span><span class="cov0" title="0">{
                        return SyncResult{}, fmt.Errorf("target agent %q not supported: %w", agent.Name, err)
                }</span>

                <span class="cov8" title="1">agentServers, err := deepCopyServers(servers)
                if err != nil </span><span class="cov0" title="0">{
                        return SyncResult{}, err
                }</span>

                // Remove any servers disabled for this agent before applying transforms.
                <span class="cov8" title="1">for _, id := range agent.DisabledMcpServers </span><span class="cov0" title="0">{
                        trimmed := strings.TrimSpace(id)
                        if trimmed == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Try exact match first
                        <span class="cov0" title="0">if _, ok := agentServers[trimmed]; ok </span><span class="cov0" title="0">{
                                delete(agentServers, trimmed)
                                continue</span>
                        }
                        // Fallback to case-insensitive match
                        <span class="cov0" title="0">for k := range agentServers </span><span class="cov0" title="0">{
                                if strings.EqualFold(k, trimmed) </span><span class="cov0" title="0">{
                                        delete(agentServers, k)
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">transformer := transforms.GetTransformer(cfg.Name)
                if err := transformer.Transform(agentServers); err != nil </span><span class="cov0" title="0">{
                        return SyncResult{}, err
                }</span>

                <span class="cov8" title="1">outputs[cfg.Name] = append(outputs[cfg.Name], AgentResult{
                        Config:  cfg,
                        Content: formatConfig(cfg, agentServers),
                })</span>
        }

        <span class="cov8" title="1">return SyncResult{Agents: outputs, Servers: servers}, nil</span>
}

// deepCopyServers creates a deep copy of the servers map to avoid
// transformations from one agent affecting another.
func deepCopyServers(servers map[string]interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        // Use JSON marshal/unmarshal for deep copy
        data, err := json.Marshal(servers)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to copy server configuration: %w", err)
        }</span>
        <span class="cov8" title="1">var copy map[string]interface{}
        if err := json.Unmarshal(data, &amp;copy); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to copy server configuration: %w", err)
        }</span>
        <span class="cov8" title="1">return copy, nil</span>
}

func formatConfig(config AgentConfig, servers map[string]interface{}) string <span class="cov8" title="1">{
        if config.Format == "toml" </span><span class="cov8" title="1">{
                return formatCodexConfig(config, servers)
        }</span>

        <span class="cov8" title="1">switch config.Name </span>{
        case "gemini":<span class="cov8" title="1">
                return formatGeminiConfig(config, servers)</span>
        default:<span class="cov8" title="1">
                return formatJSONConfig(config, servers)</span>
        }
}

// formatToJSON converts servers to JSON format with the specified node name
func formatGeminiConfig(cfg AgentConfig, servers map[string]interface{}) string <span class="cov8" title="1">{
        var existing map[string]interface{}
        if data, err := os.ReadFile(cfg.FilePath); err == nil </span><span class="cov8" title="1">{
                if err := json.Unmarshal(data, &amp;existing); err != nil </span><span class="cov0" title="0">{
                        existing = make(map[string]interface{})
                }</span>
        }
        <span class="cov8" title="1">if existing == nil </span><span class="cov8" title="1">{
                existing = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">existing[cfg.NodeName] = servers
        data, err := json.MarshalIndent(existing, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return string(data)</span>
}

func formatToJSON(nodeName string, servers map[string]interface{}) string <span class="cov0" title="0">{
        var output map[string]interface{}
        if nodeName != "" </span><span class="cov0" title="0">{
                output = map[string]interface{}{
                        nodeName: servers,
                }
        }</span> else<span class="cov0" title="0"> {
                output = servers
        }</span>

        <span class="cov0" title="0">data, err := json.MarshalIndent(output, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return string(data)</span>
}

// formatJSONConfig merges the provided servers into the existing JSON file when
// a NodeName is specified. This preserves unrelated top-level settings (like
// editor prefs) while replacing only the MCP servers node. If the existing
// file is missing or invalid JSON, a new object is created containing the
// nodeName or servers as appropriate.
func formatJSONConfig(cfg AgentConfig, servers map[string]interface{}) string <span class="cov8" title="1">{
        // If no node name is provided, just render servers as the full file.
        if cfg.NodeName == "" </span><span class="cov0" title="0">{
                return formatToJSON("", servers)
        }</span>

        <span class="cov8" title="1">var existing map[string]interface{}
        if data, err := os.ReadFile(cfg.FilePath); err == nil </span><span class="cov8" title="1">{
                if err := json.Unmarshal(data, &amp;existing); err != nil </span><span class="cov0" title="0">{
                        // If existing file can't be parsed, log a warning and fall back
                        // to an empty object so we can write a sane JSON file.
                        log.Printf("warning: failed to parse existing JSON %q: %v; overwriting mcp node", cfg.FilePath, err)
                        existing = make(map[string]interface{})
                }</span>
        }
        <span class="cov8" title="1">if existing == nil </span><span class="cov8" title="1">{
                existing = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">existing[cfg.NodeName] = servers
        data, err := json.MarshalIndent(existing, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return string(data)</span>
}

// formatToTOML converts servers to Codex TOML format
func formatToTOML(servers map[string]interface{}) string <span class="cov8" title="1">{
        var sb strings.Builder

        // Sort server names for consistent output
        names := make([]string, 0, len(servers))
        for name := range servers </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">sort.Strings(names)

        for _, name := range names </span><span class="cov8" title="1">{
                serverData, ok := servers[name].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">formatServerToTOML(&amp;sb, "mcp_servers."+name, serverData)</span>
        }

        <span class="cov8" title="1">return strings.TrimRight(sb.String(), "\n")</span>
}

// formatServerToTOML recursively formats a server and its nested sections to TOML
func formatServerToTOML(sb *strings.Builder, sectionPath string, data map[string]interface{}) <span class="cov8" title="1">{
        // Separate nested maps from simple values
        simpleValues := make(map[string]interface{})
        nestedMaps := make(map[string]map[string]interface{})

        for k, v := range data </span><span class="cov8" title="1">{
                if nested, ok := v.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        nestedMaps[k] = nested
                }</span> else<span class="cov8" title="1"> {
                        simpleValues[k] = v
                }</span>
        }

        // Write the section header and simple values
        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("[%s]\n", sectionPath))

        // Sort keys for consistent output
        keys := make([]string, 0, len(simpleValues))
        for k := range simpleValues </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)

        for _, k := range keys </span><span class="cov8" title="1">{
                v := simpleValues[k]
                switch val := v.(type) </span>{
                case string:<span class="cov8" title="1">
                        sb.WriteString(fmt.Sprintf("%s = \"%s\"\n", k, val))</span>
                case []interface{}:<span class="cov8" title="1">
                        arr := make([]string, 0, len(val))
                        for _, item := range val </span><span class="cov8" title="1">{
                                if s, ok := item.(string); ok </span><span class="cov8" title="1">{
                                        arr = append(arr, fmt.Sprintf("\"%s\"", s))
                                }</span>
                        }
                        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%s = [%s]\n", k, strings.Join(arr, ", ")))</span>
                case []string:<span class="cov0" title="0">
                        arr := make([]string, 0, len(val))
                        for _, s := range val </span><span class="cov0" title="0">{
                                arr = append(arr, fmt.Sprintf("\"%s\"", s))
                        }</span>
                        <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("%s = [%s]\n", k, strings.Join(arr, ", ")))</span>
                default:<span class="cov0" title="0">
                        sb.WriteString(fmt.Sprintf("%s = %v\n", k, val))</span>
                }
        }
        <span class="cov8" title="1">sb.WriteString("\n")

        // Sort nested map keys for consistent output
        nestedKeys := make([]string, 0, len(nestedMaps))
        for k := range nestedMaps </span><span class="cov0" title="0">{
                nestedKeys = append(nestedKeys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(nestedKeys)

        // Recursively format nested maps as separate sections
        for _, k := range nestedKeys </span><span class="cov0" title="0">{
                formatServerToTOML(sb, sectionPath+"."+k, nestedMaps[k])
        }</span>
}

func formatCodexConfig(cfg AgentConfig, servers map[string]interface{}) string <span class="cov8" title="1">{
        var existing string
        if data, err := os.ReadFile(cfg.FilePath); err == nil </span><span class="cov8" title="1">{
                existing = string(data)
        }</span>

        <span class="cov8" title="1">preserved := strings.TrimRight(stripMCPServersSections(existing), "\r\n")
        newSections := strings.TrimRight(formatToTOML(servers), "\r\n")

        var parts []string
        if preserved != "" </span><span class="cov8" title="1">{
                parts = append(parts, preserved)
        }</span>
        <span class="cov8" title="1">if newSections != "" </span><span class="cov8" title="1">{
                parts = append(parts, newSections)
        }</span>

        <span class="cov8" title="1">if len(parts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return strings.Join(parts, "\n\n") + "\n"</span>
}

func stripMCPServersSections(content string) string <span class="cov8" title="1">{
        if strings.TrimSpace(content) == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">lines := strings.Split(content, "\n")
        var sb strings.Builder
        insideMCP := false

        for i, line := range lines </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(line)
                if strings.HasPrefix(trimmed, "[") &amp;&amp; strings.HasSuffix(trimmed, "]") </span><span class="cov8" title="1">{
                        if strings.HasPrefix(trimmed, "[mcp_servers.") </span><span class="cov8" title="1">{
                                insideMCP = true
                                continue</span>
                        }
                        <span class="cov8" title="1">insideMCP = false</span>
                }
                <span class="cov8" title="1">if insideMCP </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">sb.WriteString(line)
                if i &lt; len(lines)-1 </span><span class="cov8" title="1">{
                        sb.WriteByte('\n')
                }</span>
        }

        <span class="cov8" title="1">return sb.String()</span>
}

func normalizeAgent(agent string) string <span class="cov8" title="1">{
        return strings.ToLower(strings.TrimSpace(agent))
}</span>

func dedupeTargets(targets []AgentTarget) []AgentTarget <span class="cov8" title="1">{
        seen := make(map[string]struct{}, len(targets))
        var out []AgentTarget
        for _, target := range targets </span><span class="cov8" title="1">{
                name := normalizeAgent(target.Name)
                if name == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Include a deterministic representation of disabled MCPs in the key
                <span class="cov8" title="1">disabled := make([]string, 0, len(target.DisabledMcpServers))
                for _, d := range target.DisabledMcpServers </span><span class="cov0" title="0">{
                        t := strings.TrimSpace(d)
                        if t == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">disabled = append(disabled, t)</span>
                }
                // Keep order consistent by sorting
                <span class="cov8" title="1">if len(disabled) &gt; 1 </span><span class="cov0" title="0">{
                        sort.Strings(disabled)
                }</span>
                <span class="cov8" title="1">key := name + "|" + strings.TrimSpace(target.PathOverride) + "|" + strings.Join(disabled, ",")
                if _, exists := seen[key]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[key] = struct{}{}
                out = append(out, AgentTarget{
                        Name:         name,
                        PathOverride: strings.TrimSpace(target.PathOverride),
                        DisabledMcpServers: disabled,
                })</span>
        }
        <span class="cov8" title="1">return out</span>
}

func applyOverride(overridePath, defaultPath string) string <span class="cov8" title="1">{
        if trimmed := strings.TrimSpace(overridePath); trimmed != "" </span><span class="cov8" title="1">{
                return trimmed
        }</span>
        <span class="cov8" title="1">return defaultPath</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package transforms

import (
        "fmt"
        "strings"
)

// Transformer defines the interface for destination-specific transformations.
// Each target agent can have its own transformer that manipulates server
// configurations before they are written.
type Transformer interface {
        // Transform modifies servers in place and returns an error if validation fails.
        Transform(servers map[string]interface{}) error
}

// GetTransformer returns the appropriate transformer for a given agent.
// If no specific transformer exists, it returns a no-op transformer.
func GetTransformer(agent string) Transformer <span class="cov8" title="1">{
        switch strings.ToLower(strings.TrimSpace(agent)) </span>{
        case "copilot":<span class="cov8" title="1">
                return &amp;CopilotTransformer{}</span>
        case "claudecode":<span class="cov8" title="1">
                return &amp;ClaudeTransformer{}</span>
        case "codex":<span class="cov8" title="1">
                return &amp;CodexTransformer{}</span>
        default:<span class="cov8" title="1">
                return &amp;NoOpTransformer{}</span>
        }
}

// NoOpTransformer performs no transformations.
type NoOpTransformer struct{}

// Transform returns nil without modifying servers.
func (t *NoOpTransformer) Transform(servers map[string]interface{}) error <span class="cov0" title="0">{
        return nil
}</span>

// CopilotTransformer handles Copilot-specific transformations and validations.
type CopilotTransformer struct{}

// Transform applies Copilot-specific modifications:
// - Adds an empty "tools" array to every server if not present
// - Normalizes network transport types to the values Copilot expects
// - Validates that network-based servers have both "type" and "url" fields
func (t *CopilotTransformer) Transform(servers map[string]interface{}) error <span class="cov8" title="1">{
        for name, serverRaw := range servers </span><span class="cov8" title="1">{
                server, ok := serverRaw.(map[string]interface{})
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if err := t.transformServer(name, server); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// transformServer applies transformations to a single server configuration.
func (t *CopilotTransformer) transformServer(name string, server map[string]interface{}) error <span class="cov8" title="1">{
        addToolsArrayIfMissing(server)

        if typ, ok := server["type"].(string); ok </span><span class="cov8" title="1">{
                switch strings.ToLower(strings.TrimSpace(typ)) </span>{
                case "stdio":<span class="cov8" title="1">
                        server["type"] = "local"</span>
                case "streamable-http":<span class="cov8" title="1">
                        server["type"] = "http"</span>
                }
        }

        <span class="cov8" title="1">if isNetworkServer(server) </span><span class="cov8" title="1">{
                if err := validateNetworkServer(name, server); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// isNetworkServer returns true if the server appears to be a network-based server.
// A network-based server has either "type" or "url" field (or both).
func isNetworkServer(server map[string]interface{}) bool <span class="cov8" title="1">{
        _, hasType := server["type"]
        _, hasURL := server["url"]
        return hasType || hasURL
}</span>

// addToolsArrayIfMissing adds an empty "tools" array to the server if not present.
func addToolsArrayIfMissing(server map[string]interface{}) <span class="cov8" title="1">{
        if _, hasTools := server["tools"]; !hasTools </span><span class="cov8" title="1">{
                server["tools"] = []interface{}{}
        }</span>
}

// validateNetworkServer ensures that network-based servers have both "type" and "url" fields.
func validateNetworkServer(name string, server map[string]interface{}) error <span class="cov8" title="1">{
        rawType, hasType := server["type"]
        _, hasURL := server["url"]

        if !hasType &amp;&amp; !hasURL </span><span class="cov0" title="0">{
                // Not a network server, nothing to validate
                return nil
        }</span>

        <span class="cov8" title="1">if hasType </span><span class="cov8" title="1">{
                if t, ok := rawType.(string); ok </span><span class="cov8" title="1">{
                        if strings.EqualFold(strings.TrimSpace(t), "local") </span><span class="cov8" title="1">{
                                // Copilot local transports do not require a URL.
                                return nil
                        }</span>
                }
        }

        <span class="cov8" title="1">var missing []string
        if !hasType </span><span class="cov0" title="0">{
                missing = append(missing, "type")
        }</span>
        <span class="cov8" title="1">if !hasURL </span><span class="cov8" title="1">{
                missing = append(missing, "url")
        }</span>

        <span class="cov8" title="1">if len(missing) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("copilot validation error: network-based server %q is missing required field(s): %s. Network servers must have both 'type' and 'url' fields",
                        name, strings.Join(missing, ", "))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CodexTransformer applies Codex-specific conversions.
type CodexTransformer struct{}

// Transform converts GitHub Authorization headers into the env var token expected by Codex.
func (t *CodexTransformer) Transform(servers map[string]interface{}) error <span class="cov8" title="1">{
        githubRaw, ok := servers["github"]
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">server, ok := githubRaw.(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">headers, hasHeaders := server["headers"].(map[string]interface{})
        if !hasHeaders </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if _, hasEnv := server["bearer_token_env_var"]; hasEnv </span><span class="cov0" title="0">{
                delete(headers, "Authorization")
                if len(headers) == 0 </span><span class="cov0" title="0">{
                        delete(server, "headers")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">if _, hasAuth := headers["Authorization"]; !hasAuth </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">server["bearer_token_env_var"] = "CODEX_GITHUB_PERSONAL_ACCESS_TOKEN"
        delete(headers, "Authorization")
        if len(headers) == 0 </span><span class="cov8" title="1">{
                delete(server, "headers")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ClaudeTransformer applies minimal Claude-specific conversions. Currently it
// normalizes legacy transport names like "streamable-http" to "http" so that
// Claude configs use the simpler transport type.
type ClaudeTransformer struct{}

// Transform applies Claude-specific normalizations.
func (t *ClaudeTransformer) Transform(servers map[string]interface{}) error <span class="cov8" title="1">{
        for _, serverRaw := range servers </span><span class="cov8" title="1">{
                server, ok := serverRaw.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if typ, ok := server["type"].(string); ok </span><span class="cov8" title="1">{
                        switch strings.ToLower(strings.TrimSpace(typ)) </span>{
                        case "streamable-http":<span class="cov8" title="1">
                                server["type"] = "http"</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
