
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>agent-align: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">agent-align/cmd/agent-align/main.go (47.6%)</option>
				
				<option value="file1">agent-align/internal/config/config.go (91.3%)</option>
				
				<option value="file2">agent-align/internal/syncer/syncer.go (93.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        _ "embed"
        "errors"
        "flag"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "runtime"
        "strconv"
        "strings"
        "unicode"

        "gopkg.in/yaml.v3"

        "agent-align/internal/config"
        "agent-align/internal/syncer"
)

const (
        defaultAgents = "copilot,vscode,codex,claudecode,gemini"
)

var (
        promptUser      = askYes
        collectConfig   = promptForConfig
        supportedAgents = []string{"codex", "vscode", "gemini", "copilot", "claudecode"}
)

//go:embed config.example.yml
var exampleConfig string

func main() <span class="cov0" title="0">{
        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == "init" </span><span class="cov0" title="0">{
                if err := runInitCommand(os.Args[2:]); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("init failed: %v", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">if err := validateCommand(os.Args); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">sourceAgent := flag.String("source", "", "source-of-truth agent name")
        agents := flag.String("agents", "", fmt.Sprintf("comma-separated list of agents to keep in sync (defaults to %s)", defaultAgents))
        configPath := flag.String("config", defaultConfigPath(), "path to YAML configuration file describing the source and target agents")
        dryRun := flag.Bool("dry-run", false, "only show what would be changed without applying changes")
        confirm := flag.Bool("confirm", false, "skip user confirmation prompt (useful for cron jobs)")

        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: agent-align [OPTIONS]\n\n")
                fmt.Fprintf(os.Stderr, "Options:\n")
                flag.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nDefault config file location: %s\n", defaultConfigPath())
                fmt.Fprintf(os.Stderr, "\nExample config file:\n%s\n", exampleConfig)
                fmt.Fprintf(os.Stderr, "Tip: add agent-align to cron for continuous syncing, e.g.:\n")
                fmt.Fprintf(os.Stderr, "  0 * * * * agent-align -confirm &gt;/tmp/agent-align.log 2&gt;&amp;1\n\n")
        }</span>

        <span class="cov0" title="0">flag.Parse()

        var configFlagUsed bool
        flag.Visit(func(f *flag.Flag) </span><span class="cov0" title="0">{
                if f.Name == "config" </span><span class="cov0" title="0">{
                        configFlagUsed = true
                }</span>
        })

        <span class="cov0" title="0">useConfig, modeErr := resolveExecutionMode(*sourceAgent, *agents, configFlagUsed)
        if modeErr != nil </span><span class="cov0" title="0">{
                log.Fatal(modeErr)
        }</span>

        <span class="cov0" title="0">var finalSource string
        var candidateAgents []string

        if useConfig </span><span class="cov0" title="0">{
                if err := ensureConfigFile(*configPath); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("configuration unavailable: %v", err)
                }</span>

                <span class="cov0" title="0">cfg, cfgErr := config.Load(*configPath)
                if cfgErr != nil </span><span class="cov0" title="0">{
                        log.Fatalf("failed to load config %q: %v", *configPath, cfgErr)
                }</span>
                <span class="cov0" title="0">finalSource = cfg.Source
                candidateAgents = cfg.Targets</span>
        } else<span class="cov0" title="0"> {
                finalSource = strings.TrimSpace(*sourceAgent)
                candidateAgents = parseAgents(*agents)
                if len(candidateAgents) == 0 </span><span class="cov0" title="0">{
                        log.Fatal("the -agents flag must list at least one agent")
                }</span>
        }

        <span class="cov0" title="0">if strings.TrimSpace(finalSource) == "" </span><span class="cov0" title="0">{
                log.Fatal("source agent must be provided via a config file or -source/-agents")
        }</span>
        <span class="cov0" title="0">if len(candidateAgents) == 0 </span><span class="cov0" title="0">{
                log.Fatal("no target agents configured; provide them via config or -agents")
        }</span>

        <span class="cov0" title="0">sourceCfg, err := syncer.GetAgentConfig(finalSource)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to locate source agent config for %s: %v", finalSource, err)
        }</span>
        <span class="cov0" title="0">tpl, err := syncer.LoadTemplateFromFile(sourceCfg.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to load template: %v", err)
        }</span>

        <span class="cov0" title="0">s := syncer.New(finalSource, candidateAgents)

        converted, err := s.Sync(tpl)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("sync failed: %v", err)
        }</span>

        // Display the dry run results
        <span class="cov0" title="0">fmt.Println("\n=== Dry Run Results ===")
        fmt.Println("The following configuration changes will be made:")
        fmt.Println()

        for agent, cfgContent := range converted </span><span class="cov0" title="0">{
                agentCfg, err := syncer.GetAgentConfig(agent)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: could not get config for agent %s: %v", agent, err)
                        continue</span>
                }
                <span class="cov0" title="0">fmt.Printf("Agent: %s\n", agent)
                fmt.Printf("  File: %s\n", agentCfg.FilePath)
                fmt.Printf("  Format: %s\n", agentCfg.Format)
                fmt.Printf("  Content:\n")
                // Indent the content for readability
                lines := strings.Split(cfgContent, "\n")
                for _, line := range lines </span><span class="cov0" title="0">{
                        fmt.Printf("    %s\n", line)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // If dry-run mode, exit without making changes
        <span class="cov0" title="0">if *dryRun </span><span class="cov0" title="0">{
                fmt.Println("Dry run complete. No changes were made.")
                return
        }</span>

        // If not in confirm mode, ask for user confirmation
        <span class="cov0" title="0">if !*confirm </span><span class="cov0" title="0">{
                if !promptUser("Apply these changes? [y/N]: ", false) </span><span class="cov0" title="0">{
                        fmt.Println("Changes cancelled.")
                        return
                }</span>
        }

        // Apply the changes
        <span class="cov0" title="0">fmt.Println("\nApplying changes...")
        for agent, cfgContent := range converted </span><span class="cov0" title="0">{
                agentCfg, err := syncer.GetAgentConfig(agent)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: could not get config for agent %s: %v", agent, err)
                        continue</span>
                }

                <span class="cov0" title="0">if err := writeAgentConfig(agentCfg.FilePath, cfgContent); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing config for %s: %v", agent, err)
                        continue</span>
                }
                <span class="cov0" title="0">fmt.Printf("  Updated: %s\n", agentCfg.FilePath)</span>
        }
        <span class="cov0" title="0">fmt.Println("\nConfiguration sync complete.")</span>
}

func parseAgents(agents string) []string <span class="cov8" title="1">{
        segments := strings.Split(agents, ",")
        var out []string
        for _, segment := range segments </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(segment)
                if trimmed == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">out = append(out, trimmed)</span>
        }
        <span class="cov8" title="1">return out</span>
}

func defaultConfigPath() string <span class="cov8" title="1">{
        switch runtime.GOOS </span>{
        case "darwin":<span class="cov0" title="0">
                return "/usr/local/etc/agent-align.yml"</span>
        case "windows":<span class="cov0" title="0">
                if base := os.Getenv("ProgramData"); base != "" </span><span class="cov0" title="0">{
                        return filepath.Join(base, "agent-align", "config.yml")
                }</span>
                <span class="cov0" title="0">return `C:\ProgramData\agent-align\config.yml`</span>
        default:<span class="cov8" title="1">
                return "/etc/agent-align.yml"</span>
        }
}

func ensureConfigFile(path string) error <span class="cov8" title="1">{
        if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov8" title="1"> if !errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to inspect %q: %w", path, err)
        }</span>

        <span class="cov8" title="1">prompt := fmt.Sprintf("Configuration %s not found. %sCreate a default config? [Y/n]: ", path, configPromptSuffix(path))
        if !promptUser(prompt, true) </span><span class="cov0" title="0">{
                return fmt.Errorf("configuration file %s is required", path)
        }</span>

        <span class="cov8" title="1">cfg, err := collectConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to collect configuration: %w", err)
        }</span>
        <span class="cov8" title="1">if err := writeConfigFile(path, cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">fmt.Printf("Created configuration file at %s\n", path)
        return nil</span>
}

func runInitCommand(args []string) error <span class="cov8" title="1">{
        initFlags := flag.NewFlagSet("init", flag.ExitOnError)
        configPath := initFlags.String("config", defaultConfigPath(), "path to YAML configuration file to create")
        if err := initFlags.Parse(args); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">path := *configPath
        if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                if !promptUser(fmt.Sprintf("Configuration already exists at %s. Overwrite? [y/N]: ", path), false) </span><span class="cov8" title="1">{
                        fmt.Println("Init cancelled.")
                        return nil
                }</span>
        } else<span class="cov8" title="1"> if !errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to inspect %q: %w", path, err)
        }</span>

        <span class="cov8" title="1">cfg, err := collectConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to collect configuration: %w", err)
        }</span>
        <span class="cov8" title="1">if err := writeConfigFile(path, cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">fmt.Printf("Created configuration file at %s\n", path)
        return nil</span>
}

func askYes(prompt string, defaultYes bool) bool <span class="cov8" title="1">{
        reader := bufio.NewReader(os.Stdin)
        for </span><span class="cov8" title="1">{
                fmt.Print(prompt)
                input, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return defaultYes
                }</span>

                <span class="cov8" title="1">response := strings.TrimSpace(strings.ToLower(input))
                if response == "" </span><span class="cov0" title="0">{
                        return defaultYes
                }</span>

                <span class="cov8" title="1">switch response </span>{
                case "y", "yes":<span class="cov8" title="1">
                        return true</span>
                case "n", "no":<span class="cov8" title="1">
                        return false</span>
                default:<span class="cov8" title="1">
                        fmt.Println("Please answer 'y' or 'n'.")</span>
                }
        }
}

func promptForConfig() (config.Config, error) <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        fmt.Println("\nLet's create your agent-align configuration.")
        source, err := promptSourceAgent(reader)
        if err != nil </span><span class="cov0" title="0">{
                return config.Config{}, err
        }</span>
        <span class="cov0" title="0">targets, err := promptTargetAgents(reader, source)
        if err != nil </span><span class="cov0" title="0">{
                return config.Config{}, err
        }</span>
        <span class="cov0" title="0">return config.Config{Source: source, Targets: targets}, nil</span>
}

func configPromptSuffix(path string) string <span class="cov8" title="1">{
        if path == defaultConfigPath() </span><span class="cov0" title="0">{
                return "Use -config to choose another path. "
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func promptSourceAgent(reader *bufio.Reader) (string, error) <span class="cov8" title="1">{
        fmt.Println("\nSelect the source agent:")
        for i, agent := range supportedAgents </span><span class="cov8" title="1">{
                fmt.Printf("  %d) %s\n", i+1, agent)
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                fmt.Printf("Enter choice [1-%d]: ", len(supportedAgents))
                input, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">choice, convErr := strconv.Atoi(strings.TrimSpace(input))
                if convErr != nil || choice &lt; 1 || choice &gt; len(supportedAgents) </span><span class="cov8" title="1">{
                        fmt.Println("Please enter a number from the list above.")
                        continue</span>
                }
                <span class="cov8" title="1">return supportedAgents[choice-1], nil</span>
        }
}

func promptTargetAgents(reader *bufio.Reader, source string) ([]string, error) <span class="cov8" title="1">{
        options := make([]string, 0, len(supportedAgents)-1)
        for _, agent := range supportedAgents </span><span class="cov8" title="1">{
                if agent == source </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">options = append(options, agent)</span>
        }
        <span class="cov8" title="1">if len(options) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no target agents available for source %q", source)
        }</span>

        <span class="cov8" title="1">fmt.Println("\nSelect target agents (enter comma-separated numbers, e.g. 1,3):")
        for i, agent := range options </span><span class="cov8" title="1">{
                fmt.Printf("  %d) %s\n", i+1, agent)
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                fmt.Print("Enter one or more choices: ")
                line, err := reader.ReadString('\n')
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">selections, parseErr := parseSelectionIndices(line)
                if parseErr != nil </span><span class="cov0" title="0">{
                        fmt.Println(parseErr)
                        continue</span>
                }
                <span class="cov8" title="1">seen := make(map[int]struct{}, len(selections))
                var targets []string
                valid := true
                for _, idx := range selections </span><span class="cov8" title="1">{
                        if idx &lt; 1 || idx &gt; len(options) </span><span class="cov8" title="1">{
                                fmt.Printf("Selection %d is out of range. Please use numbers from the list.\n", idx)
                                valid = false
                                break</span>
                        }
                        <span class="cov8" title="1">if _, exists := seen[idx]; exists </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">seen[idx] = struct{}{}
                        targets = append(targets, options[idx-1])</span>
                }
                <span class="cov8" title="1">if !valid </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if len(targets) == 0 </span><span class="cov0" title="0">{
                        fmt.Println("Please select at least one target agent.")
                        continue</span>
                }
                <span class="cov8" title="1">return targets, nil</span>
        }
}

func parseSelectionIndices(input string) ([]int, error) <span class="cov8" title="1">{
        trimmed := strings.TrimSpace(input)
        if trimmed == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Please enter at least one selection.")
        }</span>
        <span class="cov8" title="1">segments := strings.FieldsFunc(trimmed, func(r rune) bool </span><span class="cov8" title="1">{
                return r == ',' || unicode.IsSpace(r)
        }</span>)
        <span class="cov8" title="1">if len(segments) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Please enter at least one selection.")
        }</span>
        <span class="cov8" title="1">var selections []int
        for _, segment := range segments </span><span class="cov8" title="1">{
                value, err := strconv.Atoi(segment)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%q is not a valid number", segment)
                }</span>
                <span class="cov8" title="1">selections = append(selections, value)</span>
        }
        <span class="cov8" title="1">return selections, nil</span>
}

func writeConfigFile(path string, cfg config.Config) error <span class="cov8" title="1">{
        data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate config contents: %w", err)
        }</span>
        <span class="cov8" title="1">dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure directory %q: %w", dir, err)
        }</span>
        <span class="cov8" title="1">if err := os.WriteFile(path, data, 0o644); err != nil </span><span class="cov0" title="0">{
                printManualConfigInstructions(path, data)
                return fmt.Errorf("failed to write config %q: %w", path, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func printManualConfigInstructions(path string, contents []byte) <span class="cov0" title="0">{
        fmt.Fprintf(os.Stderr, "\nUnable to write the config file automatically. Please create %s with the following contents:\n\n%s\n", path, contents)
}</span>

func writeAgentConfig(path, content string) error <span class="cov0" title="0">{
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure directory %q: %w", dir, err)
        }</span>
        <span class="cov0" title="0">if err := os.WriteFile(path, []byte(content), 0o644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config %q: %w", path, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateCommand(args []string) error <span class="cov8" title="1">{
        if len(args) &lt;= 1 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">arg := args[1]
        if arg == "" || arg == "init" || strings.HasPrefix(arg, "-") </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("unknown command %q. Use -h for usage or run \"init\" to create a config.", arg)</span>
}

func resolveExecutionMode(sourceFlag, agentsFlag string, configFlagUsed bool) (bool, error) <span class="cov8" title="1">{
        sourceProvided := strings.TrimSpace(sourceFlag) != ""
        agentsProvided := strings.TrimSpace(agentsFlag) != ""

        if configFlagUsed &amp;&amp; (sourceProvided || agentsProvided) </span><span class="cov8" title="1">{
                return true, fmt.Errorf("-config cannot be combined with -source or -agents")
        }</span>
        <span class="cov8" title="1">if sourceProvided != agentsProvided </span><span class="cov8" title="1">{
                return true, fmt.Errorf("use -source and -agents together or rely entirely on the config file")
        }</span>
        <span class="cov8" title="1">return !sourceProvided, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "os"
        "strings"

        "gopkg.in/yaml.v3"
)

// Config describes the source and target agents defined in the YAML file.
type Config struct {
        Source  string   `yaml:"source"`
        Targets []string `yaml:"targets"`
}

// Load reads the YAML configuration from the given path and validates it.
func Load(path string) (Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return Config{}, err
        }</span>

        <span class="cov8" title="1">var cfg Config
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov8" title="1">{
                return Config{}, fmt.Errorf("failed to parse config at %q: %w", path, err)
        }</span>

        <span class="cov8" title="1">cfg.Source = normalizeAgent(cfg.Source)
        if cfg.Source == "" </span><span class="cov0" title="0">{
                return Config{}, fmt.Errorf("config at %q must define source", path)
        }</span>

        <span class="cov8" title="1">cleanTargets := make([]string, 0, len(cfg.Targets))
        for _, target := range cfg.Targets </span><span class="cov8" title="1">{
                trimmed := normalizeAgent(target)
                if trimmed == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">cleanTargets = append(cleanTargets, trimmed)</span>
        }

        <span class="cov8" title="1">if len(cleanTargets) == 0 </span><span class="cov8" title="1">{
                return Config{}, fmt.Errorf("config at %q must define at least one target", path)
        }</span>
        <span class="cov8" title="1">for _, target := range cleanTargets </span><span class="cov8" title="1">{
                if target == cfg.Source </span><span class="cov8" title="1">{
                        return Config{}, fmt.Errorf("config at %q lists %q as both source and target; remove it from targets", path, target)
                }</span>
        }

        <span class="cov8" title="1">cfg.Targets = cleanTargets
        return cfg, nil</span>
}

func normalizeAgent(value string) string <span class="cov8" title="1">{
        return strings.ToLower(strings.TrimSpace(value))
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package syncer

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"
)

type Template struct {
        Name    string
        Payload string
}

// AgentConfig holds information about an agent's configuration file.
type AgentConfig struct {
        FilePath string // Path to the config file
        NodeName string // Name of the node where servers are stored
        Format   string // "json" or "toml"
}

// SupportedAgents returns a list of supported agent names.
func SupportedAgents() []string <span class="cov8" title="1">{
        return []string{"copilot", "vscode", "codex", "claudecode", "gemini"}
}</span>

// GetAgentConfig returns the configuration information for a given agent.
func GetAgentConfig(agent string) (AgentConfig, error) <span class="cov8" title="1">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return AgentConfig{}, fmt.Errorf("failed to get home directory: %w", err)
        }</span>

        <span class="cov8" title="1">switch normalizeAgent(agent) </span>{
        case "copilot":<span class="cov8" title="1">
                return AgentConfig{
                        FilePath: filepath.Join(homeDir, ".copilot", "mcp-config.json"),
                        NodeName: "mcpServers",
                        Format:   "json",
                }, nil</span>
        case "vscode":<span class="cov8" title="1">
                return AgentConfig{
                        FilePath: filepath.Join(homeDir, ".config", "Code", "User", "mcp.json"),
                        NodeName: "servers",
                        Format:   "json",
                }, nil</span>
        case "codex":<span class="cov8" title="1">
                return AgentConfig{
                        FilePath: filepath.Join(homeDir, ".codex", "config.toml"),
                        NodeName: "",
                        Format:   "toml",
                }, nil</span>
        case "claudecode":<span class="cov8" title="1">
                return AgentConfig{
                        FilePath: filepath.Join(homeDir, ".claude.json"),
                        NodeName: "mcpServers",
                        Format:   "json",
                }, nil</span>
        case "gemini":<span class="cov8" title="1">
                return AgentConfig{
                        FilePath: filepath.Join(homeDir, ".gemini", "settings.json"),
                        NodeName: "mcpServers",
                        Format:   "json",
                }, nil</span>
        default:<span class="cov8" title="1">
                return AgentConfig{}, fmt.Errorf("unsupported agent: %s", agent)</span>
        }
}

func LoadTemplateFromFile(path string) (Template, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return Template{}, err
        }</span>

        <span class="cov8" title="1">payload := strings.TrimSpace(string(data))
        return Template{
                Name:    filepath.Base(path),
                Payload: payload,
        }, nil</span>
}

type Syncer struct {
        SourceAgent string
        Agents      []string
}

func New(sourceAgent string, agents []string) *Syncer <span class="cov8" title="1">{
        normalized := normalizeAgent(sourceAgent)
        cleanAgents := uniqueAgents(agents)
        return &amp;Syncer{
                SourceAgent: normalized,
                Agents:      cleanAgents,
        }
}</span>

func (s *Syncer) Sync(template Template) (map[string]string, error) <span class="cov8" title="1">{
        if strings.TrimSpace(template.Name) == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("template requires a name")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(template.Payload) == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("template payload cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(s.Agents) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no agents configured to sync")
        }</span>
        <span class="cov8" title="1">if _, err := GetAgentConfig(s.SourceAgent); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("source agent %q not supported: %w", s.SourceAgent, err)
        }</span>

        <span class="cov8" title="1">result := make(map[string]string, len(s.Agents))
        for _, agent := range s.Agents </span><span class="cov8" title="1">{
                result[agent] = formatConfig(agent, s.SourceAgent, template)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func formatConfig(agent, source string, template Template) string <span class="cov8" title="1">{
        // Parse the template payload to extract MCP server definitions
        servers, err := parseServersFromSource(source, template.Payload)
        if err != nil </span><span class="cov8" title="1">{
                // If parsing fails, return empty result
                return ""
        }</span>

        <span class="cov8" title="1">config, err := GetAgentConfig(agent)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">if config.Format == "toml" </span><span class="cov8" title="1">{
                return formatCodexConfig(config, servers)
        }</span>
        <span class="cov8" title="1">return formatToJSON(config.NodeName, servers)</span>
}

// parseServersFromSource extracts MCP server definitions from the source template
func parseServersFromSource(source, payload string) (map[string]interface{}, error) <span class="cov8" title="1">{
        sourceConfig, err := GetAgentConfig(source)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if sourceConfig.Format == "toml" </span><span class="cov8" title="1">{
                return parseServersFromTOML(payload)
        }</span>
        <span class="cov8" title="1">return parseServersFromJSON(sourceConfig.NodeName, payload)</span>
}

// parseServersFromJSON extracts servers from a JSON config
func parseServersFromJSON(nodeName, payload string) (map[string]interface{}, error) <span class="cov8" title="1">{
        var data map[string]interface{}
        if err := json.Unmarshal([]byte(payload), &amp;data); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse JSON: %w", err)
        }</span>

        // If nodeName is empty, assume the entire payload is the servers map
        <span class="cov8" title="1">if nodeName == "" </span><span class="cov8" title="1">{
                return data, nil
        }</span>

        <span class="cov8" title="1">servers, ok := data[nodeName].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                // Return empty map if node doesn't exist
                return make(map[string]interface{}), nil
        }</span>
        <span class="cov8" title="1">return servers, nil</span>
}

// parseServersFromTOML extracts servers from a TOML config (Codex format)
func parseServersFromTOML(payload string) (map[string]interface{}, error) <span class="cov8" title="1">{
        servers := make(map[string]interface{})
        lines := strings.Split(payload, "\n")

        var currentServer string
        var serverData map[string]interface{}

        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check for server section header [mcp_servers.servername]
                <span class="cov8" title="1">if strings.HasPrefix(line, "[mcp_servers.") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov8" title="1">{
                        if currentServer != "" &amp;&amp; serverData != nil </span><span class="cov8" title="1">{
                                servers[currentServer] = serverData
                        }</span>
                        <span class="cov8" title="1">currentServer = strings.TrimPrefix(line, "[mcp_servers.")
                        currentServer = strings.TrimSuffix(currentServer, "]")
                        serverData = make(map[string]interface{})
                        continue</span>
                }

                // Parse key-value pairs within a server section
                <span class="cov8" title="1">if currentServer != "" &amp;&amp; strings.Contains(line, "=") </span><span class="cov8" title="1">{
                        parts := strings.SplitN(line, "=", 2)
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                key := strings.TrimSpace(parts[0])
                                value := strings.TrimSpace(parts[1])
                                // Handle string values
                                if strings.HasPrefix(value, "\"") &amp;&amp; strings.HasSuffix(value, "\"") </span><span class="cov8" title="1">{
                                        value = strings.Trim(value, "\"")
                                        serverData[key] = value
                                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(value, "[") </span><span class="cov8" title="1">{
                                        // Handle array values
                                        arr := parseTOMLArray(value)
                                        serverData[key] = arr
                                }</span> else<span class="cov8" title="1"> {
                                        serverData[key] = value
                                }</span>
                        }
                }
        }

        // Don't forget the last server
        <span class="cov8" title="1">if currentServer != "" &amp;&amp; serverData != nil </span><span class="cov8" title="1">{
                servers[currentServer] = serverData
        }</span>

        <span class="cov8" title="1">return servers, nil</span>
}

// parseTOMLArray parses a simple TOML array like ["a", "b", "c"]
// This handles basic quoted strings but does not support escaped quotes within values
func parseTOMLArray(value string) []string <span class="cov8" title="1">{
        value = strings.TrimPrefix(value, "[")
        value = strings.TrimSuffix(value, "]")
        value = strings.TrimSpace(value)

        if value == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var result []string
        var current strings.Builder
        inQuotes := false

        for i := 0; i &lt; len(value); i++ </span><span class="cov8" title="1">{
                ch := value[i]
                switch </span>{
                case ch == '"' &amp;&amp; !inQuotes:<span class="cov8" title="1">
                        inQuotes = true</span>
                case ch == '"' &amp;&amp; inQuotes:<span class="cov8" title="1">
                        inQuotes = false
                        result = append(result, current.String())
                        current.Reset()</span>
                case ch == ',' &amp;&amp; !inQuotes:<span class="cov8" title="1">
                        // Skip commas outside quotes (between elements)
                        continue</span>
                case inQuotes:<span class="cov8" title="1">
                        current.WriteByte(ch)</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// formatToJSON converts servers to JSON format with the specified node name
func formatToJSON(nodeName string, servers map[string]interface{}) string <span class="cov8" title="1">{
        var output map[string]interface{}
        if nodeName != "" </span><span class="cov8" title="1">{
                output = map[string]interface{}{
                        nodeName: servers,
                }
        }</span> else<span class="cov0" title="0"> {
                output = servers
        }</span>

        <span class="cov8" title="1">data, err := json.MarshalIndent(output, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return string(data)</span>
}

// formatToTOML converts servers to Codex TOML format
func formatToTOML(servers map[string]interface{}) string <span class="cov8" title="1">{
        var sb strings.Builder

        // Sort server names for consistent output
        names := make([]string, 0, len(servers))
        for name := range servers </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">sort.Strings(names)

        for _, name := range names </span><span class="cov8" title="1">{
                serverData, ok := servers[name].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("[mcp_servers.%s]\n", name))

                // Sort keys for consistent output
                keys := make([]string, 0, len(serverData))
                for k := range serverData </span><span class="cov8" title="1">{
                        keys = append(keys, k)
                }</span>
                <span class="cov8" title="1">sort.Strings(keys)

                for _, k := range keys </span><span class="cov8" title="1">{
                        v := serverData[k]
                        switch val := v.(type) </span>{
                        case string:<span class="cov8" title="1">
                                sb.WriteString(fmt.Sprintf("%s = \"%s\"\n", k, val))</span>
                        case []interface{}:<span class="cov8" title="1">
                                arr := make([]string, 0, len(val))
                                for _, item := range val </span><span class="cov8" title="1">{
                                        if s, ok := item.(string); ok </span><span class="cov8" title="1">{
                                                arr = append(arr, fmt.Sprintf("\"%s\"", s))
                                        }</span>
                                }
                                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%s = [%s]\n", k, strings.Join(arr, ", ")))</span>
                        case []string:<span class="cov8" title="1">
                                arr := make([]string, 0, len(val))
                                for _, s := range val </span><span class="cov8" title="1">{
                                        arr = append(arr, fmt.Sprintf("\"%s\"", s))
                                }</span>
                                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("%s = [%s]\n", k, strings.Join(arr, ", ")))</span>
                        default:<span class="cov0" title="0">
                                sb.WriteString(fmt.Sprintf("%s = %v\n", k, val))</span>
                        }
                }
                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        <span class="cov8" title="1">return strings.TrimRight(sb.String(), "\n")</span>
}

func formatCodexConfig(cfg AgentConfig, servers map[string]interface{}) string <span class="cov8" title="1">{
        var existing string
        if data, err := os.ReadFile(cfg.FilePath); err == nil </span><span class="cov8" title="1">{
                existing = string(data)
        }</span>

        <span class="cov8" title="1">preserved := strings.TrimRight(stripMCPServersSections(existing), "\r\n")
        newSections := strings.TrimRight(formatToTOML(servers), "\r\n")

        var parts []string
        if preserved != "" </span><span class="cov8" title="1">{
                parts = append(parts, preserved)
        }</span>
        <span class="cov8" title="1">if newSections != "" </span><span class="cov8" title="1">{
                parts = append(parts, newSections)
        }</span>

        <span class="cov8" title="1">if len(parts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">return strings.Join(parts, "\n\n") + "\n"</span>
}

func stripMCPServersSections(content string) string <span class="cov8" title="1">{
        if strings.TrimSpace(content) == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">lines := strings.Split(content, "\n")
        var sb strings.Builder
        insideMCP := false

        for i, line := range lines </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(line)
                if strings.HasPrefix(trimmed, "[") &amp;&amp; strings.HasSuffix(trimmed, "]") </span><span class="cov8" title="1">{
                        if strings.HasPrefix(trimmed, "[mcp_servers.") </span><span class="cov8" title="1">{
                                insideMCP = true
                                continue</span>
                        }
                        <span class="cov8" title="1">insideMCP = false</span>
                }
                <span class="cov8" title="1">if insideMCP </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">sb.WriteString(line)
                if i &lt; len(lines)-1 </span><span class="cov8" title="1">{
                        sb.WriteByte('\n')
                }</span>
        }

        <span class="cov8" title="1">return sb.String()</span>
}

func normalizeAgent(agent string) string <span class="cov8" title="1">{
        return strings.ToLower(strings.TrimSpace(agent))
}</span>

func uniqueAgents(agents []string) []string <span class="cov8" title="1">{
        seen := make(map[string]struct{}, len(agents))
        var out []string
        for _, agent := range agents </span><span class="cov8" title="1">{
                normalized := normalizeAgent(agent)
                if normalized == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, exists := seen[normalized]; exists </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[normalized] = struct{}{}
                out = append(out, normalized)</span>
        }
        <span class="cov8" title="1">return out</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
